[{"content":"lec6 DLLists, Arrays\rDLList\r在lec5的 SLList中，如果想要实现获取、增加最后一个节点，需要耗费$O(n)$的时间。如何改进这一点呢？\n可以考虑引入一个指针，指向最后一个节点。这样，就可以很方便地获取和增加最后一个节点。然而，如果要删除最后一个节点，这样的方法还需要找到倒数第二个节点，比较耗费时间。\n因此，引入 DLList，也就是双向链表。这样，就可以方便地删除最后一个节点。\n然而，如果按照原先只有一个哨兵，那么，有时候 last 会指向真正的最后节点，有时候会指向第一个哨兵，这样会引入许多条件判断，很不方便。\n有两个解决办法：一、引入首尾两个哨兵。二、循环链表。\n泛型\r可以在类名定义后加上 \u0026lt;pineapple\u0026gt;，尖括号内是任意的名字。后续，可以用这个名字来指代类型。\n数组\r之后介绍了 java 的数组。因为和 C 语言的很像，所以没怎么记笔记。\nguide A level 1\r部分内容引用自TomLazy的CSDN博客。\n紫胡子和他的奴才 Turquoisenail 正在10海里航行。为了更好地航行，他们希望能够创建一张地图。他们设法创建了他们的方形地图，但 Turquoisenail 被绊倒了，把它掉在了碎纸机里。他们设法将碎掉的图像存储到1D 阵列中，但他们需要将其拼成一张 NxN 地图。你很幸运，因为每一块上都写有经度和纬度。编写一个简短的程序来帮助把这些碎片重新组合起来。\n在表格的左上角，0是经度，20是纬度，在这个问题上，你只能使用数组。\n问题一\r对于这个问题的第一部分，制作一个存储经度和纬度的 Piece 类。\n1 2 3 4 5 6 7 8 9 public class Piece { public int longitude; public int latitude; public Piece(int x, int y) { longitude = x; latitude = y; } } 问题二\r这个问题的下一部分是把给定的一维 Piece 数组中的 Piece，(Piece 没有特定的顺序)，放到一个二维数组中，每一行都充满了具有相同纬度的 Piece。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public Piece[][] groupByLat(Piece[] p) { int width = (int) Math.sqrt(p.length); Piece[][] latGroup = new Piece[width][width]; for (int i = 0; i \u0026lt; p.length; i++) { for (int j = 0; j \u0026lt; latGroup.length; j++) { if (latGroup[j][0] == null) { latGroup[j][0] = p[i]; break; } else if (latGroup[j][0].latitude == p[i].latitude) { int counter; for (counter = 0; counter \u0026lt; width; counter++) { if (latGroup[j][counter] == null) { break; } } latGroup[j][counter] = p[i]; break; } } } return latGroup; } 首先，需要计算二维数组的大小。因此使用 Math.sqrt() 函数并转换为 int 类型。然后创建二维数组。\n一开始还没想出来怎么填空，主要是没有搞清楚 i、j 和 counter 的含义。实际上，这里的 i 遍历了 Piece[] p，而 j 则是便利了二维数组的行（第一个索引）。\n每次对于一个碎片 p[i]，都首先看能否放在一个空的第 j 行当中，也就是 latGroup[j][0] == null。如果为真，直接把当前的碎片放入即可。否则，就看当前第 j 行元素的纬度是否和第 i 个碎片的纬度相同。如果不同，就跳过本次循环。如果相同，就利用 counter 遍历这一行，将当前元素放在第一个非空的位置。\n经过以上操作，就通过纬度，将原先的一维数组转换为每一行家具有相同纬度的二维数组。\nlec7 ALists, Resizing, vs. SLists\r相比于链表，数组更方便访问其中的某一个元素。 只需要记下数组的大小，就可以很方便地实现尾部元素的增加和减少。\n不变量\r下一个元素的位置总是 size。 size 总便是 AList 中元素的个数。 最后一个元素的索引总是 size-1。 更改大小\r数组的大小是有限的。如果超出了大小，就需要创建新的数组，满足大小，并且将旧数组都复制到新数组当中。\n如果需要更改大小 $n$ 次，这样做的代价大约是 $O(n^2)$。\n每一次重新分配大小，将大小变为原先的两倍。这样可以明显地提升速度。同时，如果相比于数组的大小，使用的数据量过于小（通常选择 0.25），那么可以将数组大小缩小一半，节省空间。\n泛型数组\r使用 items = (type[]) new Object[n] 来创造泛型的数组。\nlec8 Inheritance, Implements\rmethod overload\r在 java 中，一个类中的方法可以有相同的名字，但是有不同的参数。通过不同的参数，编译器可以判断具体使用哪一个方法。\n接口（Interface）\r有的方法对各种列表都适用，但是非要制定具体的 AList 或 SLList。如果使用 overload，需要复制粘贴代码，修改起来很麻烦。\n解决方法是创造一个 interface，可以代表多种列表。在新的文件中，像这样命名：\n1 public interface List\u0026lt;Item\u0026gt; { ... } 对于接口，可以描述它们做什么，但是不用描述怎么做。例如，主需要写下方法即可：\n1 public Item get(int i); 接着，在 AList 和 SLList类中，修改为这样：\n1 public AList\u0026lt;Item\u0026gt; implements List\u0026lt;Item\u0026gt; { ... } 这样，就可以使用其他方法，对于所有的 List 都有用。\n覆盖（Override）\r对于具体的类，可以选择覆盖方法：\n1 2 @Override public Item get(int i) { ... } 这里的 @Override 虽然不是必须的，但是建议这样写，一方面可以避免拼写错误，另一方面方便其他程序员明白这个方法在 Override。\n在接口中，也可以使用 default 关键字，内置一个方法：\n1 default public void method() { ... } 该方法中可以使用其他接口中的方法。\nStatic vs. Dynamic Type\rStatic type 是唯一确定的，仅仅取决于声明变量时的类型。而 Dynamic Type 可以随着程序而变化，取决于当前指向的对象的类型。\nproject1 前半部分\r这个项目分为两个部分，第一个部分需要实现数据结构，第二个部分则需要利用数据结构实现应用。\n项目介绍\rPackage\r有两个包：deque 用来实现数据结构，gh2 用来实现吉他英雄的合成器。\n包可以包含许多类，实现一个更大的目标。利用文件开头的 package deque;，就表明当前类在 deque 包当中。\n如果其他程序员想用使用某个方法，要么使用全名，也就是 deque.ArrayDeque，要么 import deque.ArrayDeque 后使用简称 ArrayDeque。\n同时，全名是倒着写的。例如，JUnit 库在 junit.org，于是包写成 org.junit。因为不同库当中可能有相同的方法，所以要制定全名或者使用 import。\nDeque\r一般读作\u0026quot;deck\u0026quot;，代表两端队列，既可以从头加入、移除元素，也可以从尾部加入、移除元素。在 The Deque API 中，说明了希望的 API。该项目需要用两种方法来实现 Deque——双向链表和数组。\nLinkedListDeque\r有一些要求：\nadd 和 remove 必须消耗常数的时间。 get 要使用迭代而不是递归。 size 要消耗常数的时间。 使用 for 循环来遍历链表。 不要保留对于不在队列当中物品的引用。 我选择了循环链表加上一个哨兵实现，这样的代码确实比较简洁。在 LinkedListDeque 的内部，我创建了 private Node 类。LinkedListDeque有两个实例变量——Node sentinel 和 int size。\n在只有一个哨兵的时候，哨兵的 prev 和 next 都设置成自身。对于头部和尾部加入元素，需要考虑清楚改变哪些指针即可。\n特别注意，对于 remove 操作，需要考虑 size 为 0 时，如果用户执行 remove，那么 size 还应该为 0。这一点我一开始还没有考虑到，经过测试才发现。\n对于 getRecursive 操作，可以创建一个私有的 helper 函数，输入 Node 和 index，利用递归完成获取第 index 节点的 item。\n完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 public class LinkedListDeque\u0026lt;T\u0026gt; { private Node sentinel; private int size; private class Node { T item; Node prev; Node next; private Node(T item,Node prev,Node next) { this.item = item; this.prev = prev; this.next = next; } } public LinkedListDeque() { this.sentinel = new Node(null, null, null); this.sentinel.next = sentinel; this.sentinel.prev = sentinel; size = 0; } public void addFirst(T item) { Node temp = new Node(item, sentinel, sentinel.next); sentinel.next.prev = temp; sentinel.next = temp; size += 1; } public void addLast(T item) { Node temp = new Node(item, sentinel.prev, sentinel); sentinel.prev.next = temp; sentinel.prev = temp; size += 1; } public boolean isEmpty() { return size == 0; } public int size() { return size; } public void printDeque() { Node p = sentinel; while(p.next != sentinel){ System.out.print(p.item); System.out.print(\u0026#39; \u0026#39;); p = p.next; } System.out.println(); } public T removeFirst() { if (size == 0) { return null; } T value = sentinel.next.item; sentinel.next.next.prev = sentinel; sentinel.next = sentinel.next.next; size -= 1; return value; } public T removeLast() { if (size == 0) { return null; } T value = sentinel.prev.item; sentinel.prev.prev.next = sentinel; sentinel.prev = sentinel.prev.prev; size -= 1; return value; } public T get(int index) { if (index \u0026gt;= size) { return null; } Node p = sentinel.next; for (int i = 0; i \u0026lt; index; i++) { p = p.next; } return p.item; } public T getRecursive(int index) { if (index \u0026gt;= size) { return null; } return recursiveHelper(sentinel.next, index); } /** Private helper for recursively get item. */ private T recursiveHelper(Node p, int index) { if (index == 0) { return p.item; } return recursiveHelper(p.next, index-1); } } Array Deque 简单部分\r要求：\nadd 和 remove 应该消耗常数时间，除非需要 resize。 get 和 size 必须消耗常数时间。 开始的数组大小为 8。 对于长度大于等于 16 的数组，可用率至少为 25%。即 remove 时，如果让可用率低于 25%，则需要 resize。 推荐使用环形的数组。\n初始化\r首先，创造相应数量为 8 的数组。然后，size 赋值为 0，并将 nextFirst 赋值为最后一个索引，nextLast 赋值为 0。\n1 2 3 4 5 6 public ArrayDeque() { items = (T[]) new Object[INIT_SIZE]; size = 0; nextFirst = INIT_SIZE-1; nextLast = 0; } 环形索引\r为了方便地实现环形，定义两个私有的 helper 方法，nextIndex 和 prevIndex。\n1 2 3 4 5 6 7 8 9 10 11 12 13 private int nextIndex(int n) { if (n+1 == items.length) { return 0; } return n+1; } private int prevIndex(int n) { if (n == 0) { return items.length-1; } return n-1; } 增减元素（不考虑 resize）\r对于增加第一个元素，首先需要将索引为 nextFirst 的元素赋值为 item，然后更改 nextFirst 为前一个索引，最后增加 size。\n1 2 3 4 5 public void addFirst(T item) { items[nextFirst] = item; nextFirst = prevIndex(nextFirst); size += 1; } 对于移除第一个元素，需要首先判断 size 是否为 0。如果是，直接返回 null 阶数函数。如果还有元素，则先将元素暂存下来，并清空数组中对元素的 reference，然后更改 nextFirst 和 size，最后返回该元素。\n1 2 3 4 5 6 7 8 9 10 public T removeFirst() { if (size == 0) { return null; } T item = items[nextIndex(nextFirst)]; items[nextIndex(nextFirst)] = null; nextFirst = nextIndex(nextFirst); size -= 1; return item; } 对于 addLast 和 removeLast 函数，方法也是类似的，这里就不再重复了。\n容易实现的方法\rget，isEmpty 和 size 都很好实现，这里就不再赘述。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public T get(int index) { if (index \u0026gt;= items.length){ return null; } return items[index]; } public boolean isEmpty() { return size == 0; } public int size() { return size; } ArrayDeque Resize\r终于来到了最有意思的地方。相比于双向链表，数组总是有一个固定的大小。如果需要更改大小，就需要手动赋值数组。\n同时，我们是通过循环数组来实现的。这就意味着，必须要判断当前的数组是否是循环的。例如，[X, 2, 3, 4, X, X] 就是不循环的，因为所有的元素都在中间部分；[2, 3, X, X, 5, 6]就是循环的，因为该数组的第一个元素是 5，然后是 6，接着因为循环，下一个元素变为 2，然后是 3。因此，需要编写函数来判断当前数组是否循环。\nisCircular\r跟函数需要返回是否循环。利用之前的 Index 操作，可以方便地找到当前数组的首元素索引和尾元素索引。然后，如果首元素的索引大于尾元素的索引，就代表存在循环；否则，不存在。\n1 2 3 4 5 6 /** If circular, return true.*/ private boolean isCircular() { int first = nextIndex(nextFirst); int last = prevIndex(nextLast); return first \u0026gt; last; } CheckExpand\r每次扩张数组时，都有可能使得当前元素个数超出数组范围。因此，每次 add 操作前都需要判断。为此编写判断的函数：\n1 2 3 4 5 6 7 8 /** Check whether after add new item, * the AList needs to expand. If so, call expandSize.*/ private void checkExpand() { if (size != items.length) { return; } resize(size * 2); } 这里选择每次扩大一倍，因为一开始的大小也是 8，这样成倍扩大后数字比较整齐。\nResize\r对于数据的更改大小，首先需要创造一个新的数组，然后将当前数组中的元素复制进新的数组。这需要分类讨论：\n如果当前数组循环，则需要从首元素到数组末尾赋值到新数组，然后从数组头部到尾元素复制到新数组。 如果当前数组不循环，则只需要复制中间部分到新数组。 复制完成后，将 items 指向新的数组，然后更新 nextFirst 为新的大小-1，nextLast 为原先大小。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** Expand array to newSize.*/ private void resize(int newSize) { T[] newArray = (T[]) new Object[newSize]; int first = nextIndex(nextFirst); // if the items are circular if (isCircular()){ System.arraycopy(items,first,newArray, 0,items.length-first); System.arraycopy(items,0,newArray, items.length-first,nextLast); } else { System.arraycopy(items,first,newArray,0,size); } items = newArray; nextFirst = newSize-1; nextLast = size; } checkEmptySpace\r如果一开始加入了很多元素，之后又减少了很多元素，那么数组不应该耗费太多空间。所以，每次删除元素的时候，都需要检查是否有多余的空间。为此编写 checkEmptySpace 函数。\n根据要求，如果当前数组长度大于 16，并且空闲率（元素个数除以数组长度）小于 0.25，那么就需要缩小数组。此时，因为空闲率小于 0.25，所以可以将数组缩小为原先长度的一半。\n1 2 3 4 5 6 7 8 /** Check whether empty space exists.*/ private void checkEmptySpace() { if (items.length \u0026gt;= MAX_EMPTY_SIZE \u0026amp;\u0026amp; size \u0026lt; 0.25*items.length) { resize(items.length / 2); } return; } 经过这些函数，数组双向队列可以基本实现。\n完整的项目代码见github上的my-cs61b。\n","date":"2024-07-15T00:00:00Z","image":"https://ovideros.github.io/p/cs61b-week3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/circular_hu0cb3e8a5ae6461545981ed543138b0ea_88986_120x120_fill_box_smart1_3.png","permalink":"https://ovideros.github.io/p/cs61b-week3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"CS61B week3 学习笔记"},{"content":"前言\r为什么没有week1的内容呢？🧐\n答案是我偷懒了，没有写。😴\n以下记录一些自己上cs61b的感悟，以及编程的思路。完整的项目代码见github上的my-cs61b。\nlab2\r这个 lab 2 主要是教你如何使用 IDEA 的 Debugger 来 debug。\n对于这种现代化的 IDE，debug 确实比较容易，可以方便地显示不同变量，提供步入步出等操作，起到隔离信息的作用。\n理想的 debug 模式：首先根据一行代码和当前变量，预期这一行代码的功能。如果一致，就说明这一行没出错；如果发现矛盾，说明这一行有问题，或者这一行调用的函数有问题。这时候，可以进一步步入函数。重复上面的步骤，直到发现问题所在。\n理想的 debug 应该实现抽象的功能，不能直接就步入每一个函数，不然只会增加工作量。应该先假设所有函数都能正常工作，直到找到不满足预期的情况。这样，才能高效地找到代码出错的部分。\n同时，课程还强调了测试驱动开发（Test-driven development, TDD）。在实际编写各种函数之前，首先写一些测试用例，同时可以考虑一些边缘的情况。然后，测试一下，自然全部都无法通过。这时候，先聚焦于比较简单的测试，想办法让该测试通过。然后，聚焦于剩下失败的测试，直到最后通过所有测试。\n相比于直接写代码，先写测试可以让你明确输入输出用例。在实际例子的帮助下，可以对代码有更深的理解。一个个通过的测试，也能像玩游戏一样，增加开发的动力。\nlec5 SLLists, Nested Classes, Sentinel Nodes\r相比于直接的 IntList，SLList 提供了更好的 api，拥有 addFirst() 方法和 getFirst() 方法，方便调用。\nPrivate\r对于用户来说，不用考虑递归的细节。\n通过将一些类的成员设置成 private，那么类之外无法访问这些成员。这可以隐藏细节。事实上，private 也不是绝对不能访问，可以用库做到这一点。它更像是一种提醒。\nNested class\r可以在类当中定义其他的类。\n嵌套的类可以实现更多的功能。\n保持代码简单\r不要增加过多特殊情况。最好寻找普遍的方法，覆盖各种情况。\n可以对链表引入假头，又称为哨兵 (sentinel)。\nproject0 2048\r这个项目需要你去实现 2048 游戏的核心功能。自然地，作为第 0 个项目，许多繁杂的部分，包括 GUI、随机生成方块、各种类的抽象，都已经写好了。只需要在 Model.java 中继续写游戏的核心逻辑即可。\n这个项目的前三个函数都很容易，最后一个tilt函数有点意思。\nemptySpaceExists\r原型： public static boolean emptySpaceExists(Board b)\n该函数接受一个 Board 输入，然后判断是否有空的格子。这需要使用 Board 的方法 tile(int col, int row) 从而得到具体的格子。需要注意，如果某个地方没有 Tile，那么该方法返回的是 null，而不是 0。我想之所以要这样写，是因为这样可以更明确地表示某个地方为空。如果是 0，可能在后续编写代码的时候有歧义。\n同时，也需要用到 Board 的 size() 方法，获得大小。代码相当简单，只需要用一个二层循环遍历每一个格子，如果某一个格子为空，返回 true 即可。否则返回 false。\n1 2 3 4 5 6 7 8 9 10 11 public static boolean emptySpaceExists(Board b) { int n = b.size(); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { if (b.tile(i,j) == null) { return true; } } } return false; } maxTileExists\r原型：public static boolean maxTileExists(Board b)\n这个函数用来检验是否有达到最大值的格子，也就是 2048。这里强调了不要直接将数字硬编码写在程序里，避免 magic number，而是要使用常量，如 MAX_PIECE 来表示2048。\n相当简单，同上，二层循环遍历格子即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static boolean maxTileExists(Board b) { int n = b.size(); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { if (b.tile(i,j) == null) { continue; } if (b.tile(i,j).value() == MAX_PIECE) { return true; } } } return false; } atLeastOneMoveExists\r原型：public static boolean atLeastOneMoveExists(Board b)\n这个函数用来判断当前是否有存在可以移动的空间。如果 Board 上还有空的格子，自然可以继续移动。如果全满，则判断是否有相邻的相同大小的格子存在。如果有，则说明还可以移动。\n要解决这个问题，可以分成两个部分——水平相邻和竖直相邻，分别检验，二者对称。可以使用二层循环。\n在检验过程中，如果发现相邻中任何一个格子为 null，则跳过当前循环。然后，使用 b.tile(col, row).value() 来获取值并且比较。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public static boolean atLeastOneMoveExists(Board b) { if (emptySpaceExists(b)) { return true; } int n = b.size(); // check whether horizontal adjacent tiles exists for (int i = 0; i \u0026lt; n-1; i++) { for (int j = 0; j \u0026lt; n; j++) { if (b.tile(i,j) == null || b.tile(i+1,j) == null) { continue; } if (b.tile(i,j).value() == b.tile(i+1,j).value()) { return true; } } } // check whether vertical adjacent tiles exists for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n-1; j++) { if (b.tile(i,j) == null || b.tile(i,j+1) == null) { continue; } if (b.tile(i,j).value() == b.tile(i,j+1).value()) { return true; } } } return false; } tilt\r原型：public boolean tilt(Side side)\n这个函数接受 Side 输入，表明往哪个方向移动。同时，方法需要修改 Board 至移动后的状态，同时增加 score 变量的值，并将 changed 变量设置为 true。\n所有的移动操作都要使用 Board.move(col, row, tile)。\n移动规则\r以下的X代表该格子为空。\n两个相同值的格子，会合成一个有两倍值的格子。 合成过后的格子不会再次参与合成。例如[X, 2, 2, 4]向左移动，则会变为[4, 4, X, X]，而不是[8, X, X, X]。 如果有大于等于 3 个相邻格子，则会先合并移动方向上的两个格子。例如，[X, 2, 2, 2]向左移动会得到[4, 2, X, X]而不是[2, 4, X, X]。 简化的手段\r首先，如果有四个移动的方向，那么最后可能要把已有的结果复制粘贴四次，并进行修改。这样很明显相当麻烦，并且很容易出错，增加了维护难度。\n因此，Board 已经内置了 setViewingPerspective(side) 方法。只要首先设置视角的方向，就可以把各个方向的操作，都转换成向上移动的操作，然后使用同样的代码求解，最后再把视角变换回来。\n同时，合并的具体过程已经经过抽象了。只需要使用 broad.move(col,row,tile) 方法。如果该移动后与原先格子发生合并，则该函数返回 true，否则返回false。\n方法\r在向上移动的时候，很明显每一列都是相互独立的，因此可以考虑封装每一列，传入 Board 和当前列的索引，进而使代码简化。\n在每一列中，因为都是向上移动，因此总可以从上往下考虑每一个格子。\n需要记录的状态\r在 public boolean tiltColumnNorth(int col) 方法中，传入 col，执行一列的操作，并且返回 boolen 代表有没有改变。\n对于每一列，从上到下，将 row 从 n-1 遍历到 0。\n为了记录好每次的状态，需要以下变量：\nrow：当前行数 lastValue：上一格的值。一开始设置为-1。 val：现在一格的值。只有在当前格非空时才有用。 lastTileRow：上一格的位置。一开始设置为 n。 isLastMerged：上一格是否合并过。一开始设置为 false。 可能的动作：\n不移动当前格。 移动当前格，但是不合并。 移动当前格，同时合并。 一开始，我没要搞清楚这几种动作，并且都写在一个函数里面，导致很难维护。后来，根据这些状态，写了一个函数calculateState，根据返回值来确定状态。然后，在 tiltColumnNorth 方法当中使用 switch 语句。\nCalculateState\r不移动的情况。这时候，row 等于 lastTileRow-1，并且上一格的值和这一格的值不相等。（此处这一格的值和上一个相等，就一定能移动，因为是从上往下遍历，不会出现上面一个格合并后还和下面的格紧挨着） 移动但是不合并的情况。这时候，要么 val 不等于 lastValue，要么 isLastMerged 值为真，也就是上面一个格合并过。 移动并且合并。是上面两种情况的剩下情况。 TiltColumnNorth\r获取状态后，就容易执行相应的操作了。\n不移动时，lastTileRow 减少 1，isLastMerged 为假，lastValue 赋值为 val。 移动但不合并时，将当前格移动到(col, lastTileRow-1)处，changed 为真，isLastMerged 为假，lastTileRow 减少 1，lastValue 赋值为 val。 移动并且合并时，将当前格移动到 (col, lastTileRow)处，changed 为真，isLastMerged 为真，lastTileRow 减少 1，lastValue 赋值为两倍的 val。 最后返回 changed。\n完整代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 /** Tilt the board toward SIDE. Return true iff this changes the board. * * 1. If two Tile objects are adjacent in the direction of motion and have * the same value, they are merged into one Tile of twice the original * value and that new value is added to the score instance variable * 2. A tile that is the result of a merge will not merge again on that * tilt. So each move, every tile will only ever be part of at most one * merge (perhaps zero). * 3. When three adjacent tiles in the direction of motion have the same * value, then the leading two tiles in the direction of motion merge, * and the trailing tile does not. * */ public boolean tilt(Side side) { boolean changed; changed = false; // TODO: Modify this.board (and perhaps this.score) to account // for the tilt to the Side SIDE. If the board changed, set the // changed local variable to true. board.setViewingPerspective(side); int n = board.size(); for (int col = 0; col \u0026lt; n; col++) { if(tiltColumnNorth(col)) { changed = true; } } board.setViewingPerspective(Side.NORTH); checkGameOver(); if (changed) { setChanged(); } return changed; } /** Tilt a certain column towards NORTH, * if changed, return true; * else, return false */ public boolean tiltColumnNorth(int col) { int n = board.size(); int lastTileRow = n; boolean changed = false; boolean isLastMerged = false; int lastValue = -1; for (int row = n-1; row \u0026gt;= 0; row--) { Tile t = board.tile(col, row); if (t == null) { continue; } int val = t.value(); switch (calculateState(lastTileRow, isLastMerged, lastValue,val,row)) { // don\u0026#39;t move case 0: lastTileRow--; isLastMerged = false; lastValue = val; break; // move, don\u0026#39;t merge case 1: board.move(col, lastTileRow-1, t); changed = true; isLastMerged = false; lastTileRow--; lastValue = val; break; //move and merge case 2: board.move(col, lastTileRow, t); changed = true; isLastMerged = true; score += 2*val; lastValue = 2*val; break; } } return changed; } /** Calculate state. * if return 0, don\u0026#39;t move * if return 1, move but don\u0026#39;t merge * if return 2, move and merge */ public int calculateState(int lastTileRow, boolean isLastMerged, int lastValue, int val, int row) { if (row == lastTileRow-1 \u0026amp;\u0026amp; lastValue != val) { return 0; } else if (val != lastValue || isLastMerged) { return 1; } else { return 2; } } ","date":"2024-07-13T00:00:00Z","permalink":"https://ovideros.github.io/p/cs61b-week2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"CS61B week2 学习笔记"},{"content":"▶️ 前言\r时间过得飞快，如今我已是老登了。去年的今日，我还在暑假期间打 P5r。鉴于自己的成绩还挺不错的，于是想要整理一下一年以来用过的学习资料，以供各位大一学生参考。虽说主要是信科，但是大一的课大差不差。就算是电信、精工、特立等学生，也可以来看看，大概80%的内容是可以参考的。\n本文大概分为三个部分——思想篇，方法篇还有资料篇。在思想篇里，我会简单地介绍一些视频或网站，帮助各位完成从高中到大学思维的转变。在方法篇里，我会介绍一些我认为的合理方法，帮助各位高效学习。在资料篇里，我会对各个科目列举出我当时使用过的学习资料，供各位参考。\n🌞 关于暑假\r大学从来不是四年。有人说，大学只有三年，因为保研的流程从大三的寒假开始，直到大四的 9 月 28 号，满打满算也只有三年的时间；考研要在大四的 12 月初试，也没有四年。也有人说，大学有五年，因为如果想要在竞赛或科研中取得较好成果，假期是几乎必须要牺牲的；如果把牺牲的寒暑假加起来，那么大学就有五年。\n为什么我要这么说呢？答案是：高考后的暑假是最方便玩的暑假。如果以后想要走保研的路，那么高考暑假大概率是一生中最长的假期了。所以，好好玩吧。喜欢社交的可以多交些朋友，喜欢宅的可以多看看 ACGN，喜欢干什么就干什么吧。因为我暑假也是玩过来的，所以个人给不上任何建议。\n💛 心态篇\r鉴于独特的教育环境，大学和高中的转变，远远比小升初、初升高的转变要大。这个过程可能是艰难的，但我希望各位通过充分了解，可以让这个过程更加轻松。\n以下，我会推荐五个有关大学认知的视频或文章，帮助大家思考。我在这只起到推荐作用，如果你有兴趣，也可以自行探索相关内容，进行更加深入的了解。我希望能帮助同学们拓宽视野，找到在大学中前进的方向。\n1️⃣\r普通出身，如何最大限度“利用”大学？【学生请一定看完！】\n该视频先提出了优势与弱势学生的划分，进而提出了两种类型的学生——“目标掌控者”与“直觉依赖着”。这两者的形成正是源于学生曾经所处的环境。\n在以上的分析以后，作者提出了解决方案：“学生必须主动投入，积极投身学校的各类教育实践, 提升学习成果，主动与老师和同学互动，才更有可能取得成功。”作者因此鼓励我们减少自己所谓的“标签”，努力保持积极投入的状态；要克服道德策略，挑战习以为常的观念。在最后，作者也表达了自己的希望与祝福。\n2️⃣\r在第一个推荐后，各位也许会想：“如何积极投入大学呢？”那么，下面的的视频，就是专门解决这个问题的。\n一个视频讲透大学的一切！2023年所有高校均适用\n可以看到，这个视频有 2 个多小时，相当长。自然地，没必要一次性看完，可以慢慢看。\n该视频从大学的重要话题谈起，之后介绍了大学的信息渠道，阐释了如何规划大学道路，最后还讲了一下各个年级的主要工作。可以说，大学中80%以上的问题，都可以在其中找到答案。\n3️⃣\r“大学物理”背后的教学问题与社会问题\n视频梗概\r开头，作者提问：为什么许多大学生对于大学物理不理解甚至抵触？为什么许多本科基础课程被大量人吐槽？有没有正确的路，让理工科学生学好物理及其他基础学科？\n一：物理学科的真正面貌\n物理的普遍性。数学与物理的区别。物理将数学当做重要工具，但物理也很看重直观想象。\n二：“大学物理”可能出现的学习与教学问题\n第一：高中和大学脱节\n第二：基础课程与专业需求脱节\n第三：高数与大物的比较\n接着，作者给出建议：\n教学问题不能上升到对学科本身的批判 打好数学基础 走出高中物理的舒适圈，体现在要注意公式的适用范围 远离题海战术，注重整理 三. 一些社会问题＆结束语\n个人感悟\r所幸，北理在大物的安排上相对科学，从大一下才开始学。这意味着，在学习大物时，同学们已经有了微积分的基础。同时，工科数学分析里面也有一些与物理相结合的知识点与题目，这起到了一定的衔接作用。\n然而，我也不能一味说北理的好话。如果把视野扩大，我依然能看到现有本科教育存在着的一些问题。例如，在高度信息化的时代，在纸上画工程制图真的有用吗？又比如，在信息技术日新月异的今天，十几年前的大学计算机实验软件，在表达形式上是否过于落后？诸如此类的问题的确存在着。\n4️⃣\r上海交通大学生存手册\n《上海交通大学生存手册》，写于 08 年，后经过一些修改。这本册子的内容之广，难以简单概括。在此，我仅仅截取一些“名言警句”，希望能激励各位去阅读它：\n“国内绝大部分大学的本科教学，不是濒临崩溃，而是早已崩溃。”\n“我衷心希望这本书能够带给读者一些新鲜的思考，让同学们能看到人生道路上不同的风景。至少在读过本书之后，各位读者应该能够有勇气、有智慧，去发现并挑战那些比上课更为重要的追求。”\n“如果一个人把政策评分作为自己的至高追求，那么他就是这个政策的牺牲品。”\n“学习最需要的，不是悲壮的毅力，而是对无限未知的渴求。”\n“某个环境的条件如何如何之好并不是你去到某个环境中的理由，你能从这个环境中获得什么样的成就，才是你前往某个环境的原因。”\n5️⃣\rCS自学指南 “这是一本计算机的自学指南，也是对自己大学三年自学生涯的一个纪念。”该书由北大的一名信科学生所写，包含了许多部分：必学工具，环境配置，经典书籍推荐，以及最重要的——国外高质量 CS 课程汇总。\n在前言中，作者详细讲述了自己的大学体验，揭示了自己写作此书的理由，还分析了自学的好处与坏处。这当中的资源相当丰富，涵盖面也相当广。在 CS 方面，如果各位有什么想学的知识，在其中基本都可以找到相应的推荐。\n用作者自己的话来说：“当然，作为一个还未毕业的本科生，我深感自己没有能力也没有权利去宣扬一种学习方式，我只是希望这份资料能让那些同样有自学之心和毅力朋友可以少走些弯路，收获更丰富、更多样、更满足的学习体验。”\n🔧 方法篇\r经过高中三年的折磨，如果各位想要继续在学习上取得进步，按照惯性，大概也会沿着高中学习的方向来走。然而，鉴于极度应试的环境，高中也带来了不少自我感动乃至于摧残式的学习方案。当然，下面也只是表示我个人的看法，学习方法也因人而异，仅供各位选择性参考。\n🏫 关于一些学习行为\r简单来说，学习的目的在于获得更多的知识，拓宽自己的视野，而不是获得更多所谓的学习时长。在我看来，效率是比时间要重要的多的。$1.5 \\times 4= 1 \\times 6$，高效的四小时的学习要好于低效的 6 小时学习。\n同时，有一些学习行为也没有太多作用。例如，抄笔记、手抄错题等。在信息化日渐普及的今天，在可以使用各类电子产品的大学，抄笔记不如直接找到书本的电子版，或者把感兴趣的内容拍下来；手抄错题更是没意义，如果用平板等设备来刷题，可以很方便地利用软件来整理。\n📚 什么是高效的学习\r那么，什么样的学习是高效的呢？简单来说，如果某一种方法让你在学的过程中越感到费脑子，那么这个方法就越高效。因为简单的行为——抄笔记、被动听课，都几乎不怎么需要思考；然而更有效的学习方法——整理一门课的大纲、深入研读课本、选择性听课、按类别主动整理错题等，都需要更高的参与度。只有充分调动大脑，让你在学的时候感到有些费脑子，这个方法才是有效的。\n📓 我的日常学习过程\r在日常上课过程中，我一般都是认真听课的。然而，遇到思政课、水课、或讲得实在烂的专业课，我确实不怎么听。对于理工科课程，最重要的是听懂一些思想，例如工数的极限思维、积分思维，线代的一些抽象思维，大物的形象理解，电分的叠加、等效、变换三大方法等等。这些思维对于理解各类理工科，都是通用的。\n课后，认真完成作业。同时，一定要关注慕课、乐学等在线平台的截止时间，否则会扣平时分。\n对于一些自己认为没有特别理解的概念，我会选择寻找一些学习资料，来帮助自己理解。我主要通过课本，其他教材还有 b 站视频来寻找。同时，也有些人会看 MOOC，延河课堂等等。\n可以说，我在平时阶段没有那么应试，还是注重真正的理解。因为，很多时候考试是千变万化的，无法保证今年的难度和往年相同。举两个例子：22-23 年的工数下是有往年题以来最难的一届，题量大，计算量恐怖；在老师将许多人捞到 60 分后，平均分也只有 65 分。又比如 23-24 年的电分，也就是我们大一下信科类的电分，在我刷过 20 年以来的所有试卷后，我敢说今年是最难的，没有之一。如果有兴趣，各位在大一下也可以挑战一下这些试卷。\n所以，平时阶段还是要真正理解概念，不能纯粹应试。否则，期末考试可能会超出你的意料之外。\n🤺 考前突击\r大学的一大特色就在于考前突击。区别于高中三年认真学 6 门科目，在大学中，你一个学期就要学相当于高中三年的知识量。此时，不管平时学得怎么样，考前突击都是必需的。对于比较重要的课，我考前突击的时间线比较长，可以有两周到三周。不过，如果某个课重要程度一般，并且时间比较紧，一周的时间大概也够了。\n往年试卷是最好的参考。虽然我上面说不能只看往年卷，不过如果往年卷都不看，那我不知道有什么更好的资料。\n我一般会把有记录的考试卷全部都刷一遍。有的科目从 04 年开始，有的科目从 08 年开始。然而，我并不是每一个试卷都从头刷到尾，而是借用了机器学习的方法——划分训练集和测试集。具体来说，如果有过往 16 年的往年题，我可能把前 12 年的题目当成训练集，最近 4 年的题目当成测试集。\n对于训练集的题目，我会根据题型来刷。例如，当我复习完工科数学分析上的极限这一章，我就会一个个看训练集当中的题目。如果找到了极限的题目，就做一做；对于其他还没有复习到的章节，则不管。就这样，每复习完一章，就做完训练集中的所有相关题目，并在最后作总结。这样，这一章差不多就通关了。\n在考前最后 2-3 天，可以开始做测试集的题目。这时候，尽量按照考试的要求来严格模拟。做试卷的时候找集中的时间做，模拟考场的氛围。如果你学得比较好，你往往会发现，自己做的时间远低于考试的 2 个小时。然而，这些科目往往又会有不少的低级错误。例如，我发现我做线代往年题大概只要 1 个小时，工数上往年题只要一个小时十几分钟。对于这种科目，考试的时候一定要放慢解题步骤，不要太快，否则很容易出现低级错误。相反，有的科目题量较大，例如我发现如果认真画完工图，就要用 1 个小时 40 多分钟；因此，对于此类科目，考场上要保持较快的速度，不能太慢。\n考试前，不要熬夜，尽量保持最充足的睡眠。这样考试的时候才能有最好的状态。\n📃 资料篇上\r关于军训\r军训会影响学分，分为两个部分：军事技能和军事理论。军事技能 2 学分，如果获得了优秀标兵什么的，可以加分。军事理论 2 学分，在军训最后闭卷考试，很简单，考前会发题库，背下来就行。\n工科数学分析Ⅰ\r大一上最重要的一门课，有 6 学分。内容是单变量微积分，包括极限、微分、积分。很显然，这是对高中导数的延续，通过研究导数的逆运算——积分，可以解决实际理工科当中许多问题。\n在此，推荐 3blue1brown 的视频。该视频从导数讲起，深入极限的本质，还涉及到了泰勒展开。可以说，这是对微分学相当好的入门视频。\n【官方双语/合集】微积分的本质 - 系列合集\nUP 主汉语配音【微积分的本质】合集\n在科普方面，推荐一下《微积分的力量》这本书。这个书讲了微积分的各个方面，公式不多，高中生就能看。自然地，科普书看不看关系也不大。\n同时，推荐一下《普林斯顿微积分读本》。该书讲得很细致，深入浅出，不需要太多数学基础就可以看。学好这本书，可以为单变量微积分基础打下坚实的基础。\n在 b 站上有些教学视频，例如宋浩、梨米特等等。因为我数学基础较好，所以看了些考研难度的考研竞赛凯哥。\n最后复习阶段，要重点看每一章最后一节综合例题，也要认真做每一章最后的综合习题。可以配合《工科数学分析习题全解》。这当中许多来源于往年压轴题，如果吃透这些题，你就具有了考 100 分的资格。当然，这些题难度较高，如果时间紧，可以不看。\n线性代数 B\r信科学习的是线代 B，与线代 A 相比，简单不少。不过，线性代数对于之后理工科还是相当重要的，因此最好多学一学。\n在几何直观理解方面，强烈推荐 3b1b 的视频——线性代数的本质。该视频以线性变换为中心，利用几何直观，展现出线代的美丽画卷。同时，也可以看看漫士沉思录的无痛线代系列，也通过几何直观，讲解了线代的应用。\n【官方双语/合集】线性代数的本质 - 系列合集\nUP 主汉语配音-【线性代数的本质】合集 线性代数很难学？因为没有深刻理解这个概念【无痛线代】\n我们学校有一位线代的名师——吴惠彬老师。非常有幸上了吴老师的课，老师的上课节奏把握得很好，深入浅出，平时分给满，是最理想的大学老师。也可以在延河课堂上看老师的录播。\n同时，MIT 的课也很不错。\n麻省理工学院 - MIT - 线性代数\n最后突击期间，刷往年题就够了。线代B 的题型很固定，多刷刷就能上 90。\n工程制图 C\r信科的工图C 是最简单的工图。然而，这门课对信科后续学习几乎没什么作用，除非搞机器人的机械设计啥的。如果老师讲得不太行，可以看看清华的课\n【清华大学】机械制图 58 集全\n自然，这个课当中有些内容是涉及不到的，选择性观看即可。\n工图有三次大作业。我们班这一届第一次大作业要在 A 3 纸上画图，第二次用 CAD 电脑画二维图，第三次用 SolidWorks 建三维模型。可能有其他班都是在纸上画的。如果对电脑不太熟悉，可以参考一些 B 站教程。\n「速成」全网最简单的 AutoCAD 入门教程没有之一 「速成」全网最简单的 SW 入门教程没有之一（上）\n大学计算机\r这是我大一上包括各类思政课，考得最低的一门课。这门课本身就挺抽象的，本意是过一遍计算机知识，然而实际上用各种陈旧的信息，十几年前的实验软件，实在很没意思。往年题也不多。\n顺带一提，我还被大计的慕课背刺过。这个慕课考试在期末考试之后，导致我根本没看慕课，结果慕课就 45 分。折算成 20% 到总分里面，太痛了。所以直到出成绩前，一定要常常检查慕课。\n只能推荐一下计算机科学速成课，这个视频做的挺好的。\n【计算机科学速成课】[40 集全/精校] - Crash Course Computer Science\n思想道德与法治\r作为一门思政课，重点还是在于背诵。同时，还有一个红色文物大赛的项目，有兴趣可以组队做一下，算是比较容易水的竞赛。\n期末考试只会考几道大题，背诵的时候只用背重点内容，考试的时候临场发挥，拥有正能量即可。\n知识产权法基础\r水。考试的时候开卷，可以带课本，直接抄就行。\n学术用途英语一级\r英语平时分占 40%，口语考试占 20%，期末占 40%。英语课成绩主要要看老师。如果老师不错，那么你可以在愉悦的情况下拿下不错的成绩。如果不幸遇上了“冥师”，那么确实很折磨。\n考试题型和四六级比较像。大一上就可以把四级考了，顺便刷一些四级题目，增加一些英语应试能力。\n形势与政策\r水中水，0.25 学分。注意论文查重率，不要挂科就行。\n大学生心理素质发展\r水中水中水，0 学分，事有点多，但不挂就行。\n国家安全概论\r1 学分，但是最后是等级制，也就是优秀对应 95 分，良好对应 85 分（记不清了，可能是）。没有考试，主要是平时作业和结课论文。认真让 gpt 写一下就行。\n📑 资料篇下\r大一下相比于大一上，有了很大的变化。23届大一上期末周只有3门课程，其他课在之前就已经考完了。而大一下只有电分提前考，剩下六门课都在考试周。\n如图，橙色的点代表大一上的科目，蓝色的点代表大一下的科目。很明显，大一上的科目的平均分高于大一下科目，同时大一下科目还有更多高学分的课。这就导致大一下课程又多又难。下面，我将简单介绍一下各个科目。\n工科数学分析 Ⅱ\r工数下有 6 学分，仍然是大一下最重要的课。相比于工数上的单变量微积分和常微分方程，工数下拓展到多变量微积分，理解难度上了一个台阶。\n可以在寒假期间看一看 3b1b 在可汗学院的视频，从几何直观讲解了多元微积分。\n（熟肉合集）多元微积分，微分部，3 Blue 1 Brown Grant Sanderson 讲授——可汗学院\n与工数上一样，b 站上宋浩、梨米特、考研竞赛凯哥等也可以看。\n最后突击期间，最好做一下每一章的综合例题和综合习题，不过难度确实很大。最好配合《工科数学分析习题全解》。往年题还是要刷的。\n大学物理 A Ⅰ\r简而言之，量大。包含力学、热学、波动、光学，有许多公式。如果想要学好，需要耗费一些精力。\n强烈推荐郭爷的物理讲解。作为北理光电学院的教师，郭爷讲的大学物理相当好。在高中时期，我学物理竞赛的时候，就受到了郭爷不小的帮助。到如今，也是在他的帮助下，我大物上才取得了高分。\n2019-2020-4-大一春季《大学物理-上》完整版本 75 课时\n大物的慕课较多，需要每周注意完成。最后期末复习时，可以刷课本上每章后的习题，刷往年题。\n电路分析基础\r电分作为电路的专业入门课，有一些难度。一开始的纯电阻电路还比较好理解，但是进入动态电路之后，便上了难度。学好电分，需要对工数上的常微分方程熟悉，同时理解叠加、分解和变换三大方法。书上前言写得其实不错，可以看快。\n石群老师讲得很细，不过太长了，我也只看了一点点。 电路石群老师主讲【80 集全带目录】\n我主要还是看课本。相比于 ppt，课本的原理部分讲解更多，解释更加详细，可以帮助理解。应试方面，这个考研视频也可以看看。\n邱关源《电路》第六版课后习题详解 1-8 章\n考前突击时，期末卷还是要写的。慕课上的题质量不错，可以复习。\nC 语言程序设计\r这是我大一下理科中考得最烂的一门。C 语言的考试分为三个场次，每个场次有两套试卷。我在下午考，有 C 卷和 D 卷。我看都没看，就选择了 C 卷，结果有道题目比较恶心，没写出来。然而，据说 D 卷相当简单，我有个同学一个小时就写完了。所以，如果各位可以选择试卷，一定要先把两张试卷的大题都看完，然后选择更容易的一张试卷。\n对于 OI 选手，我不敢提什么建议。如果没学过编程，可以看看 CS50 的前几讲，生动并且详细地介绍了 C 语言。\n【中文精翻】【CS 50】哈佛大学计算机科学导论课 (2023) - CS 50 Lecture 0 - Scratch\n日常的乐学编程题最好尽早做。考前可以做一下课本每章后的选择题，这些题在 csdn 上有答案。\n物理实验 B Ⅰ\r简而言之，折磨王。给它 1 点学分，它可以每周占用 4-5 个小时。再给它一次选课的机会，它能让广大学生破防。\n选课方面，可以问问学长，有一些选课秘籍可以帮助你抢到课。也可以问一些给分较好的老师。实验的预习报告可以在思政课上抄。\n学术用途英语二级\r和英语一级一样，要看老师。最后考试的听力很恶心，建议多刷一些六级听力。虽说如果你英语实力不是很好，我不建议大一下就考六级，因为大一下的期末周前很忙。\n中国近现代史纲要\r这个课有微课大赛，有兴趣的话可以水一水。该课还有一个实践活动。\n最后一节课要认真听。同时，考前可以看一下速成视频。\n【古埃及掌管史纲的神】史纲速成｜第一章 进入近代后中华民族的磨难与抗争｜Strik0r\n习概\r有的老师会要求课前放一些表演的视频。最后一节课有 ppt 划重点，考试几乎都是考重点，背好重点即可。\n形势与政策\r水中水，注意查重率就行。\n⏹️ 尾声\r以上都是关于分数的。然而，大学远远不只这些。就学业方面，还有竞赛和科研。竞赛方面，如果有 OI 经历，自然可以想办法入 acm 队；如果对自动化、机器人感兴趣，可以考虑机器人队、航模队、智能车队等等。大一下也有许多竞赛的机会，可以尝试大创、挑战杯、数学竞赛、数学建模竞赛等等。科研方面，大一确实有些早，可以之后再考虑。\n学业之外，大学还有更多。在百团大战，可以多看看不同种类的社团和学生组织，参加一些自己感兴趣的。多了解一些新的事物，尝试一些新的方法，毕竟，大学是试错成本相当低的场所。\n最后，我也要对给予过我帮助的老师们，朋辈导师们，耐心的学长学姐们，表示深深的感谢。\n","date":"2024-07-11T15:45:07+08:00","image":"https://ovideros.github.io/p/%E4%BF%A1%E7%A7%91%E5%A4%A7%E4%B8%80%E9%80%9A%E5%85%B3%E6%8C%87%E5%8D%97/grades_hu1140f049c82ac1bdd0a53595f9c2e19c_74005_120x120_fill_q75_box_smart1.jpg","permalink":"https://ovideros.github.io/p/%E4%BF%A1%E7%A7%91%E5%A4%A7%E4%B8%80%E9%80%9A%E5%85%B3%E6%8C%87%E5%8D%97/","title":"信科大一通关指南"},{"content":"前言\r🚧🚧🚧\n本笔记主要参考了3b1b的线性代数的本质，以及漫士沉思录的线性代数系列。本文尚未完成，还在施工中\u0026hellip;🫠\n🚧🚧🚧\n基本概念\r向量\r向量是线性代数中最基本的概念。一个向量在不同人的眼中，可以有许多种理解。对于物理学家，向量就是既有大小又有方向的量，不在乎起点；对于计算机科学家，向量就是一个数列，储存着一定顺序的数字。对于数学家，向量可以更加抽象，只要满足“线性”性质，就可以是向量。\n向量的线性性质\r对于向量来说，拥有以下两种运算，便具有线性：\n数乘。向量整体乘以 $k$，就是每个分量都乘以 $k$。乘了数之后，该向量仍然具有意义。 相加。两个向量相加，就是每个分量分别相加。新的向量仍具有意义。 向量最基本的几何含义，表示从原点开始，指向坐标系中某一点的有向线段。该向量可以数乘 $k$，代表该向量在经过原点的一条直线上运动。两个向量相加，符合平行四边形法则，且可以先沿着 $x$ 轴移动一段距离，再沿着 $y$ 轴移动一段距离，符合定义。\n从这个角度上来说，物体的位移、速度，显然可以加倍，也可以相加，所以是向量。电路当中的多个支路电流组成向量，可以数乘——代表状态翻倍；也可以相加，代表电路在不同激励下的响应。类似地，化学方程组中元素的个数，也可以看做向量。\n线性组合\r“线性代数”中，“线性”显然是一个重要的因素。线性组合的概念，也与向量的线性性质关系紧密。已知有两个向量 $\\vec{x}$ 和 $\\vec{y}$，此时， $$ a\\vec{x}+b\\vec{y} $$ 就是两个向量的线性组合，其中 $a$ 与 $b$ 为任意实数。\n张成的空间\r拥有了 $n$ 个向量之后，便可以考虑这 $n$ 个向量之间的线性组合。随意变化每个向量前面的系数，就可以得到一大堆向量。为了方便想象，默认这些向量的起点都是原点，可以用向量的终点来表示一个向量。此时，线性组合产生的所有向量，可以看成一个空间，也称为由 $n$ 个向量张成的线性空间。\n例如，对于零向量，张成的空间就是原点。对于一个非零向量，张成的空间是过原点的一条直线。对于两个不共线的向量，张成的空间就是一个过原点的平面。\n线性相关与基底\r线性相关\r理解了张成的空间后，便可以考虑一些独特的情况。例如，明明有两个二维向量，但是它们共线，于是最终张成的空间只是一条直线。这时候，可以认为有一个向量是多余的，因为一条直线最少只需要一个向量就可以张成。该多余的向量也可以由另一个向量线性组合得出，因为都在同一个直线上。\n接着，考虑三维中的情况。如果有三个共平面的向量，那么只能张成一个过原点的平面。此时，任意一个向量显然可以通过另外两个向量线性表示，因为该向量处在另外两个向量张成的空间上。\n更一般地，只要存在某一个向量可以被其他向量线性组合得出，那么这些向量就是线性相关的。\n线性无关\r显然，线性无关是线性相关的对立面。如果每一个向量都不能被其他向量线性组合得出，那么，这些向量就是线性无关的。更严谨地说，就是不存在一组不全为 0的 $k_1,k_2,\\ldots,k_n$，使得 $$ k_1\\vec{x_1}+k_2\\vec{x_2}+\\ldots+k_n\\vec{x_n}=0 $$ 这里，之所以要强调不全为 0，就是因为如果系数全为 0，显然等式恒成立。因此要排除这种情况。\n基底\r对于一个线性空间，总可以用一些向量张成。此时，如果这些向量线性相关，那么可以去掉一个向量；如果还线性相关，可以继续删去向量，直到这些向量是线性无关的。此时，我们便找到了张成这个空间所需的最少向量，这些向量可以成为该空间的基底，这些向量的个数就是空间的维数。\n线性变换与矩阵\r线性变换\r线性变换，又可以叫线性映射，可以看成一个函数。它的输入是一个向量，输出也是一个向量。那么，区别于其他函数，线性变换有什么特点呢？答案也是线性： $$ f(k\\vec{x})=kf(\\vec{x}) $$ $$ f(\\vec{x}+\\vec{y})=f(\\vec{x})+f(\\vec{y}) $$ 先来考虑一些几何直观。经过线性变换之后，某个向量如果是其他向量的线性组合，那么，变换后的该向量也是变换后其他向量的线性组合，系数不变。以二维平面为例，可以理解为变换后坐标网格仍然平行分布且等距，同时原点不动。\n线性变换在理工科中普遍存在，拥有广泛的应用空间。例如，对于鸡兔同笼问题，将数头数脚的过程看成变换，输入为鸡和兔数量组成的向量，输出为头和脚数量组成的向量。如果输入的动物数量翻倍，显然头和脚的数量也翻倍。对于两个笼子，可以分别根据鸡兔数量算出头和脚，再相加；也可以看成一个笼子，直接数出鸡兔的数量，得到头和脚的数量。因此，该变换满足线性性质。所以，是一个线性变换。\n同样，对于化学方程式配平，将输入看成各个化学物质前的系数，输出为元素左边总量减去右边总量。根据元素守恒，输出应该是零向量。显然，将输入翻倍，也就是把化学方程式两边乘以一个系数，仍然成立。将两个化学方程式相加，也就是对应系数相加后，输出可以是分别作用的相加，也可以看成一个式子的结果。因此，该变换满足线性性质。\n矩阵的由来\r既然我们涉及到了线性变换，那么，如何用定量的方式来表示一个线性变换呢？答案是利用线性变换的性质：某个向量如果是其他向量的线性组合，那么，变换后的该向量也是变换后其他向量的线性组合，系数不变。\n特别地，变换前的向量使用基向量线性组合表示，那么变换后的向量也可以用变换后的基向量表示。因此，只要记录变换后的基向量在哪里，就可以完全描述线性变换。\n在二维空间中，假设变换后的 $\\vec{i}$ 变为 $$ \\begin{bmatrix}a \\\\ c \\end{bmatrix} $$ 变换后的 $\\vec{j}$ 变为变为 $$ \\begin{bmatrix} b\\\\ d \\end{bmatrix} $$那么，将这两个向量按列拼起来，就可以得到 2 乘 2 的矩阵 $$ \\begin{bmatrix} a\u0026amp;\tb\\\\ c\u0026amp;\td \\end{bmatrix} $$ 这就是矩阵的由来。\n矩阵的含义\r正如前面所说，矩阵表示线性变换，因此有 $$ \\begin{bmatrix} a\u0026amp;\tb\\\\ c\u0026amp;\td\\\\ \\end{bmatrix} \\begin{bmatrix} x\\\\ y\\\\ \\end{bmatrix} =x \\begin{bmatrix} a\\\\ c\\\\ \\end{bmatrix} +y\\begin{bmatrix} b\\\\ d\\\\ \\end{bmatrix} $$ 这代表原先空间中某一向量 (x, y)，变换过后的坐标，可以通过 x 数乘变换后的 $\\vec{i}$ 加上 y 乘以变换后的 $\\vec{j}$ 得到。因此，可以得到矩阵乘以向量的计算公式。不难看出，这也可以推广到 3 维空间或者更高维的情况。\n矩阵乘以矩阵\r矩阵乘以矩阵代表什么呢？我们可以这样想：首先考虑变换前的某一向量。经过第一次变换，向量移动到了某个新的位置。再经过第二次变换，向量到达了第二个位置。此时，因为变换是线性的，所以两次变换后，网格仍然平行且等距，原点不变，这表示可以用一个线性变换等效两次线性变换。这也就是矩阵的乘法由来： $$ M_2M_1=M $$ 注意，因为矩阵和函数一样，放在输入量的左侧，因此该式子表示先进行 $M_1$ 变换，再进行 $M_2$ 变换。\n矩阵乘以矩阵如何计算呢？还是从线性变换的角度来考虑。原先的 $\\vec{i}$ 经过第一次变换，变成了 $M_1$ 的第一列。这个向量再经过第二次变换，通过矩阵和向量的乘法，就可以得到 $\\vec{i}$ 经过两次变换的最终位置，也就是 $M$ 的第一列。同理，可以计算出 $M$ 的第二列。这也很容易推广到高维矩阵的情况。\n直观理解的优点\r考虑这样一个问题： $$ M_2M_1?M_1M_2 $$ 这个等式成立吗？从数值的角度，不方便理解。但是从几何的角度，这很直观。考虑逆时针旋转 90 °的变换，以及将 $\\vec{j}$ 移动到 (1,1)的剪切变换。如果先转 90°，再剪切，那么此时 $\\vec{i}$ 会移动到 (1,1)。如果先剪切，再转 90°，那么 $\\vec{i}$ 是 (0,1)。显然，这两种情况下， $\\vec{i}$ 变换后的坐标不一样，所以不相等。\n再比如： $$ (AB)C=A(BC) $$ 这个式子要怎么证明呢？数值上看上去比较复杂，但是如何从几何的角度，这相当显然。因为先 $C$，再经历 $AB$ 等效的线性变换，与先经历 $BC$ 的等效变换，再经历 $A$ 的线性变换，显然是相等的。\n列空间和秩\r列空间\r一个矩阵可以看成是许多个列拼起来得到的。这时候，我们考虑每一个列中的向量，它们张成的空间是什么呢？事实上，这些列向量也就是变换后的基底，因此，这些列向量的线性组合，就是经过矩阵的线性变换之后，所得到的新的空间。\n秩\r对于不同的矩阵，它的列空间不一样。对于这些不同的列空间，最重要的区别就是维度。例如，对于这个矩阵 $$\\begin{bmatrix} 1\u0026amp;\t4\\\\ 2\u0026amp;\t8\\\\ \\end{bmatrix} $$ 显然，它的第一列和第二列线性相关，因此，它的列空间是一条直线，维度为 1。此时，为了衡量列空间的维度，我们称这个矩阵的秩为 1。\n事实上，在严格的线性代数教材中，会证明一个矩阵的各行组成的向量组的秩和各列向量组成的向量组的秩是一样的。\n满秩\r如果一个矩阵的秩就等于该矩阵的维度，就表示该经历该线性变换后，维度没有发生变化。这时候，可以称该矩阵满秩。\n线性方程组\r线性方程组的表示\r如果说为什么线性代数能够在这么多理工科中拥有广泛的应用，最基本的，就是因为线性代数可以方便地求解多元一次方程组，并且采用一种简单、一致的方法求解。\n$$ \\begin{cases} ax+by=e\\\\ cx+dy=f \\end{cases}\\Leftrightarrow \\begin{bmatrix} a\u0026amp;\tb\\\\ c\u0026amp;\td\\\\ \\end{bmatrix} \\begin{bmatrix} x\\\\ y\\\\ \\end{bmatrix} = \\begin{bmatrix} e\\\\ f\\\\ \\end{bmatrix} $$ 如公式，二元一次方程组可以表示为一个二维向量乘以 2 x 2 矩阵，得到了新的二维向量。从线性变换的角度，已知某个向量变换后的位置，需要求出变换之前所在的位置。\n满秩线性方程组的解法\r如果这个变换之后的维度与变换之前的维度相同（也就满秩），并且矩阵是方阵，那么问题相对简单。此时，只需要找到该变换的逆变换，将逆变换作用到变换后的向量，就可以得到变换前向量的位置。这就好像是倒放一样，从后面的向量反向推出之前的向量。使用公式来表示，也就是 $$ x=A^{-1}b $$\n逆矩阵的计算原理\r经过一次变换，再经过一次逆变换，相当于没有变换，也就是基底的位置没有移动。这可以便是为单位矩阵 $I$，其主对角元都为 1，其他都为 0。则对于满足上述条件的矩阵，有 $$ A^{-1}A=I $$ 通过这个式子，如果想要计算 $A$ 的逆矩阵，有一个方法：通过高斯消元法，想办法将 $A$ 变为 $I$，同时，在 $A$ 矩阵右侧并上单位矩阵 $I$，每一次高斯消元法时，同时对一整行处理。这样，当你把 $A$ 变为 $I$ 时，可以看成给 $A$ 做了一次线性变换，这个变换就是 $A$ 的逆。同时，这个变换也记录在了原先 $A$ 右侧的单位矩阵上，通过变换，它变成了 $A^{-1}$。\n零空间\r上述讨论的，都是不改变空间维数的变换。如果空间维数改变，就不能通过上述方法求解了。这时候应该怎么办呢？\n首先考虑较为简单的情况：一个线性变换将二维平面压成了一维直线。这种维度上的缺失意味着什么呢？这意味着原先肯定有多个点，在变换后被压成了同一个点。否则，不可能让维度发生变化。\n这同时意味着该矩阵的秩为 1，不满秩。因此，肯定存在某一个列向量线性组合为 0。 $$ k_1\\vec{x_1}+k_2\\vec{x_2}=0 $$ 同时，该线性组合的系数也可以任意变化，因为等式右侧为 0，两边可以任意乘以系数。那么，考虑如果画出 $$ \\begin{bmatrix} k_1\\\\ k_2 \\end{bmatrix}​ $$ 那么，会组成一条直线。这条直线上每一个向量，经过线性变换，都会到达原点。因此，称这条直线为矩阵的零空间。\n更一般地，如果有一个三阶矩阵秩为 2，就代表将三维空间压缩成二维平面。此时，零空间也是过原点的一条直线。如果有一个三阶矩阵秩为 1，就代表将三维空间压缩成一条一维直线，这时候，零空间是经过原点的一个平面。\n可以发现，矩阵的秩加上零空间的维度，总等于矩阵本身的列数。或者说，矩阵的列空间的秩加上零空间的秩，等于列数。这是线性代数基本定理。\n齐次线性方程组的解法\r如果线性方程组的常数项为 0，就是齐次的情况。这时候，求线性方程组的解，就是寻找矩阵的零空间。这可以通过高斯消元法化简，进而表示出零空间的基底，从而写出零空间的表达式。\n非齐次线性方程组的解法\r对于非齐次线性方程组，首先需要经历齐次线性方程组同样的求解步骤，先求解出零空间。然后，通过代入值，可以找到一组特解。\n此时，非齐次特解加上齐次通解，因为线性的性质，所以总满足原等式。所以，非齐次线性方程组的解也就是非齐次特解加上齐次通解。\n行列式\r行列式的由来\r很多国内教材第一章就讲行列式，然而，我却选择在此处才讲到行列式。因为只有通过线性变换的视角，行列式才更有意义。\n对于不同的线性变换，有的线性变换是扩张性的，将网格向外拉伸；有的线性变换是收缩性的，将网格向内挤压。应该如何描述这两者情况的不同呢？基于线性性质，可以考虑某一块面积在变换前后的大小之比。如果变换后面积变大，那么是扩张性的；如果面积变小，那么是收缩性的。\n对于不同的网格区域，因为是线性变换，所以可以知道，这些区域面积变化的比例是一样的。就算对于一个不规则区域，也可以利用微积分的思想，将其分为许多不同的小块，每个小块的面积变化比例相同。\n行列式的性质\r行列式有几个基本的性质： 1. $$ \\det(\\vec{u},\\vec{v})=\\det(\\vec{u}+k\\vec{v},\\vec{v}) $$ 在几何上，这代表平行四边形的一边可以在其直线上移动，不改变面积的大小。又称为平移不变形。 2. $$ \\det(\\vec{u_1}+k\\vec{u_2},\\vec{v})=\\det(\\vec{u},\\vec{v})+k\\det(\\vec{u_2},\\vec{v}) $$ 这表示的是行列式的线性性质。可以将其中一个向量分成多个向量的和，再分别计算这些向量和另一个向量的行列式，最后相加。 3. $$ \\begin{vmatrix}1\u0026amp;0\\\\0\u0026amp;1\\end{vmatrix}=1​ $$ 这也是二维面积的最初定义。对于更高维的情况，也就是单位矩阵的行列式为 1。\n行列式的计算\r通过以上三条性质，可以证明 $$ \\begin{bmatrix}a\u0026amp;b\\\\c\u0026amp;d\\end{bmatrix}​=ad-bc $$ 这也就是二维行列式的计算公式。对于三维行列式，可以通过行列式的性质，化简为多个二维行列式。这又被成为行列式的展开。\n🚧🚧🚧\n施工中，未完待续\u0026hellip;😶‍🌫️\n🚧🚧🚧\n","date":"2024-07-09T17:02:35+08:00","image":"https://ovideros.github.io/p/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/cover111_hu87de9121abb1737434a06c4b544edc20_178388_120x120_fill_box_smart1_3.png","permalink":"https://ovideros.github.io/p/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","title":"线性代数基本概念"}]