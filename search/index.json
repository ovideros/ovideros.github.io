[{"content":"lec26 Prefix Operations and Tries\r引入\r对于 Map 和 Set，已经讨论过了多种实现方式，包括平衡二叉树和哈希表。不过，其实还有其他方式来实现。\n字符的 keyed map\r例如对于 ASCII 字符，可以使用数组。索引为对应的 ASCII 吗，值为对应的字符。显然，时间复杂度为 $\\Theta(1)$。\nString 的 keyed map\r在 trie 中，每个节点储存一个字符。如果是蓝色，则代表这个路径的单词存在；如果是白色，则代表不存在。 搜索\r在搜索的时候，如果当前字符不在 trie 中，就说明不存在。或者最后一个字符在 trie 中，但是节点是白色，说明该字符串不存在。\nTrie 的实现与性能\r实现\r可以发现，这当中储存的 ch 实际上是多余的。可以仅仅根据对应索引来得到字符。 性能\r对于字符串个数 N 来说，Trie 中 add 的时间为 $\\Theta(1)$ ，contains 操作也为 $\\Theta(1)$。对于字符串长度 L 来说，add 操作为 $\\Theta(L)$ ，contains 操作为 $O(L)$。\n不同数据结构的性能比较如下： 然而，trie 的缺点也很明显，那就是有很多无效的链接，空间消耗较多。\n其他方法\r哈希表\r为了避免大量无效的链接，使用哈希表。\n二叉树\r使用二叉树来表示链接的部分。\n字符串操作\r找到所有字符串\r通过递归，不断调用子节点，收集字符串。 找拥有前缀的字符串\r对于 Trie 来说，比较好用的性质就是得到拥有某一前缀的单词，或者根据某一单词找到最大拥有的前缀。\n首先根据前缀，找到初始节点，然后调用 colHelp()。\n自动补全\r利用字典树，构造从字符串到重要程度的 Map。利用前缀的性质，可以很方便地实现。\n为了优化算法，每个节点不仅仅储存自身的值，还储存子节点中最优的值。同时利用 PQ。\n对于没有分支的一串节点，可以压缩成一个节点。这成为 radix tree 或者 radix trie。\nlec27 Software Engineering I\r复杂性\r引入\r和其他工程原则不同，软件并不是通过物理原则来限制的。很多时候，最大的限制是要清楚我们在创造什么，也就是创造力。\n有一些 IDE 工具，调试器，可视化工具等，可以帮助处理复杂性。但是，最重要的原则是保持简单。\n有两种方式来管理复杂性：\n让代码简单、明显（例如使用虚拟头结点来减少特殊情况） 封装，模块化 本质\r复杂性就是任何让人难以理解和修改系统的软件结构。在代码中，例如过多的条件判断，过多的缩进层次等，都会难以理解。\n如果一小部分的代码相当复杂，但是其他人几乎不会看这些部分，那么总的影响很小。\n症状\r修改难度：一个简单的改变，需要在多个地方更改。 认知难度：要进行一个更改，需要知道多少。 有时候代码更多，分成小部分，更容易理解。 增加变量说明用途，也能减小认知难度。 未知的未知：甚至不知道需要知道什么，才能进行修改 分析\r一开始，程序都是清晰、简单的。但是随着进展，逐渐变得丑陋。许多微妙的互相关联，会导致之后难以修改。尽量每一次更改都要尽可能简洁。\n编程方式\r战术式编程\r不花时间自考整体的设计 增加了许多细小的复杂性 每一个复杂性看上去很小，但总体却很大 战略性编程\r仅仅可以跑的代码是不够的。\n最重要的是长远的系统结构 不能为了短期而增加复杂性 对于每一个新的类或者任务：\n不要只是实现第一想法，而是尝试一些其他想法 当你觉得一些方法很清晰，就实现它 在现实系统中：思考在未来事情可能需要哪些改变，确保你的设计考虑了这些改变 然而，战略性编程也相当难。需要思考设计，同时也很难真正提前设计复杂的软件系统。\nlec28 Reductions and Decomposition\r拓扑排序\r在有向图中，箭头表示前者必须在后者之前发生。如何找到一种排序，满足这种限制？\n一开始，可能认为先找到所有“根节点”，也就是没有被指向的节点，然后同时使用 BFS。 然而，图稍微变一下，这个方法就不适用了。\n考虑从起点开始使用 DFS，利用后序记录数字。保留所有标记。然后从另一个起点开始使用后序 DFS，补充在一开始列表的后面。最后翻转列表，得到结果。\n之后，得到的列表中，指针方向都是向右的。\n该算法也不一定从头结点开始。可以选择随机的节点，DFS 后，从没有标记的节点中随机选，直到全部标记。\nDAG 的最短路径\rDAG 也就是有向无环图。这类图肯定可以拓扑排序。\n正如之前所说，如果有负值，此时 Dijkstra 可能会失效。为了解决这个问题，先利用拓扑排序，然后利用拓扑排序的顺序来遍历节点，更新每个边。\n最长路径\r在一般的图当中，没有适用的好算法，只有指数增长的算法。这是一个还没有解决的数学难题。\nDAG 上的最长路径\r只要把值翻转就行。然后，使用 DAG 上的最短路径即可。\nReduction\r在刚刚的问题中，通过翻转符号，让 DAG 上最长路径问题，转换为了最短路径问题，之后再变换回来，问题得到了解决。这叫做“归约”。\n","date":"2024-08-06T00:00:00Z","image":"https://ovideros.github.io/p/cs61b-week11%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/lec26-1_hu870e4ef5e45382ab863acbdb14b0a577_64648_120x120_fill_box_smart1_3.png","permalink":"https://ovideros.github.io/p/cs61b-week11%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"CS61B week11学习笔记"},{"content":"lec23 Shortest Paths\r引入\rBFS 只会考虑边的个数。如果每个边有不同的长度，那么就不能简单地使用 BFS。\n显然，最佳的路径不会有圈。\n很有趣的是，最后各个节点的最优路径会形成一棵树。包括有向图和无向图。这个路径成为 Shortest Path Tree（SPT）。\n在 SPT 中，边的个数总数 V-1，V 为节点的个数。\n尝试\r第一个算法\r一开始所有节点的距离设置为无穷。然后进行深度优先搜索，对于相邻每个节点，如果不在 SPT 中，就加入这个边。然而，这样无法得到最短的路径，因为只要有节点被标记，就不再遍历相应的边。\n第二个算法\r利用深度优先搜索，如果某个边可以产生更短的距离，就将这个边加入 SPT。在这个例子中，考虑 C 之后应该重新考虑 B，才有可能得到最短路径。 Dijkstra\r不要用深度优先，而是用\u0026quot;best first search\u0026quot;。\n在每一次选择下一个遍历的节点时，聚焦于距离最短的那个节点。然后，计算各个边带来的距离，并且更新最短距离。 ![lec23-2 1.png](lec23-2 1.png)\n将所有的点插入 fringe PQ，储存节点距离源的距离。重复以下步骤：\n从 PQ 中移除距离最小的节点 更新该节点指向的所有边，包括 distTo 和 edgeTo lec24 Minimum Spanning Trees\r引入\r如何判断一个图当中是否有圈？\n一：使用 DFS。从某个节点开始，直到遇到标记过的节点，但是不包括刚刚来的节点。最差情况是 $\\Theta(V+E)$\n二：使用并查集。对于每条边，检查两个节点是否相连。如果没有，就连接。如果有，就代表有环。最差情况为 $O(V+E\\log*(V))$\n最小生成树\r只在无向图中存在。生成树是图的一个子集，包含所有节点，并且是连接、无环的。最小生成树意味着每条边的值加起来最小，即 MST。 在有些图中，从某些节点出发的 SPT 并不是 MST，但有些节点是。但有些图中，根本没有 SPT 是 MST。所以，不能通过先确定某个节点，再根据 Dijkstra 来找到 MST。\nCut 特性\rCut 将图中节点分类两类非空集合。一个交叉边就是连接两个不同集合节点的边。Cut 特性：给定任意的 Cut，拥有最小值的交叉边一定是 MST 的一部分。这可以通过反证法证明。 ![lec24-2 1.png](lec24-2 1.png)\n利用这个，可以找到一个 cut，它的交叉边都不在 MST 中，然后将最小值加入 MST。不断重复。\nPrim 算法\r第一次选取最短的边。然后考虑所有标记过的节点，将其和剩余节点看做一个 cut，然后找到最小值的边。当有两个相同最小值时，选择任意一个都行。有时候，MST 不是唯一的。\n为了让 Prim 算法更高效，在 PQ 中储存节点距离树的距离。然后，找到最小的，将这个点从 fringe 中移除。 Dijkastra 考虑距离起点的距离，Prim 考虑距离树的距离。\n在 E 大于 V 的情况下，时间复杂度为 $O(E\\log(V))$。\nKruskal 算法\r将所有边排序，从小的开始。如果加入后不导致成环，那就加入。与 Prim 不同，这个在过程中并不一定是互相连接的。\n每次考虑最小边，将该节点在的一个树与剩余部分看成 Cut，根据性质，最小边在 MST 当中。\n在实现中，为了判断成环，可以使用并查集。如果当前边对应节点在并查集中不相连，就连接两个节点；否则，说明成环，不能加入该边。为了追踪最小边，使用 PQ。\n最终的消耗的时间主要取决于将所有边从 PQ 的加入、删除的时间，也就是 $O(E\\log(E))$。不过，如果已经知道了图中各个边的大小次序，那么运行时间主要取决于并查集的速度，需要进行 E 次连接、是否连接的操作，总时间缩减到 $O(E\\log*V)$。\nlec25 Multidimentional data\r多维数据引入\r对于多维数据，不能简单地使用一个 BST 达到方便搜索的目的。例如对于有 x、y 坐标的对象，如果使用 x 坐标来构建二叉树，那么可以很方便地找到 x 坐标小于 1.5 的点。\n通过剪枝，可以减少需要搜索的情况。 多叉树\r四叉树\r不像二叉树一样只有两个子节点，四叉树有四个节点，表示在二维空间中四种位置关系。和二叉树一样，不同的插入顺序会影响树的性能。\n这时，要进行矩形的搜索更方便。如果矩形在某一点的四个区域之内，就可以对剩下的区域进行剪枝。\n三维数据\r类似地，可以使用八叉树。\n然而，当维度更高的时候，使用这种思想就不太行，空间会呈指数型增长。\nK-D 树\r如果维度为 2，那么根节点根据 x 分类；深度为 1 的节点通过 y 分类；深度为 2 的节点通过 x 分类。以此类推。\n有时候，如果发现数值相同，需要打破平衡，例如进入右子节点。\n在寻找距离某个点最近的节点时，也可以使用 k-d 树方便地通过遍历，直到最近节点所在的区域。需要注意，还需要在之前没考虑的区域考虑。这种考虑也要靠近更好的区域。在之后考虑更差的区域时，判断该区域最优情况下的距离是否好于当前值。如果不是，可以剪枝。 均匀分割\r将空间分成多个 buckets。在矩形搜索中，只用看在矩形之中的 buckets。不过，性能会比不上四叉树或 k-d 树。\n均匀分割的思想和 hashing 比较像。\n","date":"2024-07-31T00:00:00Z","image":"https://ovideros.github.io/p/cs61b-week9-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/lec23-1_hub18ef14dc4183ea9d79e62e98a373d5e_75304_120x120_fill_box_smart1_3.png","permalink":"https://ovideros.github.io/p/cs61b-week9-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"CS61B week9 学习笔记"},{"content":"lec20 Heaps and PQs\rPriority Queue 接口\r拥有以下四个方法：\nvoid add(Item x)，将物品 x 加入 PQ Item getSmallest() 返回 PQ 中最小的物品 Item removeSmallest() 移除并返回 PQ 中最小的物品 int size() 返回 PQ 物品的数量 任务\r需要从 N 个消息中，找出最负面的 M 个消息。\n一种显而易见的做法，就是先将 N 个消息根据负面程序排序，然后找出前 M 个最负面的。这在空间上会使用 $\\Theta(N)$ 的内存。\n如何利用 MinPQ，仅仅使用 $\\Theta(M)$ 的内存呢？\n一开始正常加入。如果物品超过了 M，每次都移除最小的元素。之后，就只有满足需求的 M 个物品。\n不同的实现方法： 理论上，平衡 BST 效果较好，然而算法较为复杂，同时不能储存多个相同值得物品。\nHeap\rBinaryi min-heap：完全的二叉树，并且每一个节点小于等于它的子节点。 对于堆来说，获得最小元素相当简单，就是根节点的值。\n如果要插入，首先需要保证完备性。之后，将节点不断上爬，直到保证该节点大于等于父节点。如图： 如果要删除最小值，根据完整性，首先让最后一层的最右侧填充根节点。然而，这不满足大小，因此不断与子节点交换，直到满足特性。 Tree 的表示\r1\rA： 每个节点拥有值 key，同时拥有多个子节点的指针。\nB： 不是直接的拥有多个子节点的指针，而是有一个指针数组，每个分别指向一个子节点。缺点是代码更麻烦，性能可能下降。\nC： Sibling Tree，一个指针指向下一层第一个节点，另一个指针指向 sibling。 2\r用一个数组来储存 keys，用另一个数组来储存 parents。在并查集当中就是这么做的。\n3 a\r在完全二叉树中，只使用一个数组来存储值。\n为了寻找某个节点的父节点，可以使用当前节点的 $k$ 进行运算，得到 $(k-1)/2$。根据 Java 整数除法，这样就可以得到父节点的索引。 3 b\r留出第一个空间，这样表达父节点、子节点很简单。 数据结构总结\r搜索问题：拥有大量数据，希望找到有用的信息。 抽象往往有多个层次。例如对于 heap 树，也有多种实现的方法。 数据结构就是整理数据的一种特殊方法。\nlec21 Graphs and Traversals\r树的遍历\r树有许多种形式，包括公司中的组织结构，一个物种的树，文件系统等等。\n很多时候，需要遍历树，即 tree traversal。\n层序遍历\r先遍历完第一层，再遍历完第二层，以此类推。\n深度优先遍历\r分为三种：前序、中序和后序。 通过直观的方式，可以方便理解。从根节点开始，逆时针画一个圈包裹树。对于前序遍历，就访问每次路径在节点左侧的节点。对于中序遍历，就访问每次路径经过底部的节点。对于后序遍历，就访问每次路径经过右侧的节点。 图\r定义\r在图当中，两个节点之间可以有多个路径，并且可以有圈。\n简单图：\n没有边会连接到自身节点。 没有两条边会连接两个相同的节点。 通常，算法中涉及到的图都是简单图，因此之后说“图”的时候默认是“简单图”。\n有向图和无向图：边是否有方向。 循环图：能否通过边来回到原先的节点。 路径：一系列由边连接的节点。 相连：如果两点之间有路径，就成为相连。 图是相连：所有点之间都是相连的。 图的问题\r两点之间最短的路径是什么？最长的没有循环的路径是什么？ 是否有环？ 是否可以经过所有节点？ 是否可以经过所有的边？ 常见问题：\nS-t Path：s 和 t 之间是否有路径 Connectivity：图是否是相连的 Bioconnectivity：是否某个节点移除后，导致图不相连？ Shortest s-t Path：找出 s 和 t 之间的最短路径 Cyle Detection：是否有环 Euler Tour：是否有环可以刚好使用所有边一次 Hamilton Tour：是否有环可以刚好使用所有节点 Planarity：是否可以在二维平面上没有交叉的边 Isomorphism：两个图是否同构 有些图的问题很难解决，且不同问题难度相差极大。例如 Euler tour 在 1873 年就解决了，而今天 Hamilton Tour 也没有高效的算法，最好的算法也需要指数时间。\n深度优先\rS-t Connectivity\r如果直接用递归，会出现无限循环。因此，每次经过某个节点 s，就标记 s，之后只搜索没有标记过的节点。此处有 demo 寻找路径\r通过深度优先，也可以找到从一个节点，到剩下所有节点的路径（不是最短的）。\n为了储存路径，设置一个新的数组 edgeTo，保存着当前路径的上一个节点。通过 marked 和 edgeTo，可以遍历图，找到路径。 图与树遍历的区别和联系\r在树当中的前序、中序和后序，都相当于图当中的深度优先。图当中深度优先的前序，是每次经过一个节点，就打印出来。图当中深度优先的后序，可以理解为每一次阶数一个查找，要返回的时候，再打印出相应的节点。 与树当中的层级遍历类似，图当中也可以由广度优先搜索。\nlec22 Graph Traversals and Implementations\r广度优先\r为了实现广度优先算法，需要使用队列。将队列称为 fringe。\n将节点 v 加入队列 对于每一个没有标记的 v 的邻居 n: 标记 n 更新路径 edgeTo[n]=v 更新距离 distTo[n]=distTo[v]+1 将 n 加入队列 之后在队列中去除 v Graph API\r需要决定图的 API，以及相应的底层数据结构。\n整数节点\r对于非整数节点，可以使用一个 Map 将其他元素映射到整数。\n可能有如下的 API。对于这种 API，可以使用遍历的形式，打印出所有的边。 图的实现\r不同的实现方式会影响运行时间和内存使用量。\n1 矩阵\r对于有向图，矩阵不是对称的。不过，对于无向图，转置后与原先相同，具有对称性。 对于遍历邻居的操作，需要消耗 $\\Theta(V)$ 的时间，其中 V 为节点的数量。\n2 HashSet\r使用 HashSet，Set 中每个元素为 Edge，包含一对节点。\n3 列表的数组\r数组的索引就是对应节点的值。每个数组中指向一个列表。其中遍历一个节点邻居的运行时间介于 1 到 V 之间。如果要打印所有的边，那么运行时间是 $\\Theta(V+E)$，也就是节点和边的个数之和。\n对于不同种类的图，因为 V 和 E 之间的数量关系不同，所以打印的运行时间也会不同。\n性能比较\r实际上很多算法依赖于 adj()，而 adjacency list 在这方面的表现最好。\n遍历算法和耗时\r通常将遍历的方法写在另一个类当中，方便使用。 只需要使用 marked，就可以判断是否有路径。对于 pathTo 方法，首先需要遍历 edgeTo，然后将储存的路径反向。 广度优先的运行时间也是 $O(V+E)$。\nlab8 MyHashMap\r抽象\r首先，需要实现 MyHashMap 继承自接口 Map 61 B，与 lab 7 中一样，都需要拥有一些方法。其中，remove 方法是选做的。\n对于 HashTable 而言，具体的 buckets 可以有很多种实现方法，例如链表、数组、二叉树、PQ 等等。为了兼容各样的实现方式，需要使用抽象。\n将具体的 Mapping 设置为 Node 类，仅仅包含 key 和 value。上述提到的实现方式都是 Collection，因此，在 MyHashMap 中会有 Collection\u0026lt;Node\u0026gt; createBucket() 方法，返回一个 bucket。例如，通过 return new LinkedList\u0026lt;\u0026gt;();，就可以指定使用链表来实现。\n对于其他不同的实现方法，可以继承 MyHashMap，并且 Override 对应的 createBucket() 方法。\n对于这当中的 Collection 而言，只应该使用 add、remove 和 iterate 来交互。这样才可以保证不同实现方法的兼容性。\n实例变量和初始化\r正如说明中所说，为了方便起见，直接使用默认的 HashSet 来创建 key 的集合。\n1 2 3 4 private Collection\u0026lt;Node\u0026gt;[] buckets; private int size = 0; private Set\u0026lt;K\u0026gt; keySet = new HashSet\u0026lt;\u0026gt;(); private double loadFactor = 0.75; 初始化很简单。\n1 2 3 4 5 6 7 8 9 10 11 12 13 /** Constructors */ public MyHashMap() { buckets = createTable(INIT_SIZE); } public MyHashMap(int initialSize) { buckets = createTable(initialSize); } public MyHashMap(int initialSize, double maxLoad) { buckets = createTable(initialSize); loadFactor = maxLoad; } 为了保持一致性，使用 createNode 和 createTable 方法。特别注意，createTable 需要调用 createBucket() 方法，这样才能实现多态。\n1 2 3 4 5 6 7 8 9 10 11 protected Collection\u0026lt;Node\u0026gt; createBucket() { return new LinkedList\u0026lt;\u0026gt;(); } private Collection\u0026lt;Node\u0026gt;[] createTable(int tableSize) { Collection\u0026lt;Node\u0026gt;[] col = new Collection[tableSize]; for (int i = 0; i \u0026lt; col.length; i++) { col[i] = createBucket(); } return col; } 这里还有一个小细节。对于 Collection\u0026lt;Node\u0026gt;[] 的创建，不能写上 \u0026lt;Node\u0026gt;。这是 Java 的小特性，因此直接写 new Collection[tableSize] 即可。\n查找\r对于清零操作，只需要都赋值为新的空指针就行。\n1 2 3 4 5 @Override public void clear() { Arrays.fill(buckets, createBucket()); size = 0; } 为了实现 hashing，需要根据 key 来获取对应的索引。因此，创建 hashIndex 方法。特别注意，当在 resize 的时候，不能简单地使用当前的 buckets 长度来得到索引。因此，这里加入了第二个参数 length。\n1 2 3 private int hashIndex(K key, int length) { return Math.floorMod(key.hashCode(), length); } 于是，可以实现是否含有 key 的查找方法 containsKey。注意要使用 .equals() 方法。\n1 2 3 4 5 6 7 8 9 10 @Override public boolean containsKey(K key) { Collection\u0026lt;Node\u0026gt; bucket= buckets[hashIndex(key, buckets.length)]; for (Node node : bucket) { if (node.key.equals(key)) { return true; } } return false; } 对于 get() 方法，几乎一样，只需要返回对应的 value 就可以。\n1 2 3 4 5 6 7 8 9 10 @Override public V get(K key) { Collection\u0026lt;Node\u0026gt; bucket= buckets[hashIndex(key, buckets.length)]; for (Node node : bucket) { if (node.key.equals(key)) { return node.value; } } return null; } 插入\r在插入的时候，有可能会需要调整大小。因此，编写 checkResize() 方法检查是否需要更新大小。\n1 2 3 4 5 private void checkResize() { if ((double) size / buckets.length \u0026gt;= loadFactor) { resize(buckets.length * 2); } } 在调整大小的时候，需要先创建新的大小的 newbuckets。然后遍历原先 buckets，并且遍历每一个节点。然后，将每一个节点计算 hash 值，放入新的 newbuckets 中。最后让 buckets 指向 newbuckets。注意这里的 hashIndex 在调用时，要使用 newSize。\n1 2 3 4 5 6 7 8 9 private void resize(int newSize) { Collection\u0026lt;Node\u0026gt;[] newBuckets = createTable(newSize); for (Collection\u0026lt;Node\u0026gt; bucket : buckets) { for (Node node : bucket) { newBuckets[hashIndex(node.key, newSize)].add(node); } } buckets = newBuckets; } 在此基础上，可以实现 put。需要注意，如果之前已经有相同的 key，那么就将原先的 value 替换为新的 value。因此这需要遍历 bucket 中的每一个 node。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Override public void put(K key, V value) { Collection\u0026lt;Node\u0026gt; bucket= buckets[hashIndex(key, buckets.length)]; keySet.add(key); boolean flag = false; for (Node node : bucket) { if (node.key.equals(key)) { node.value = value; flag = true; } } if (!flag) { Node newNode = createNode(key, value); bucket.add(newNode); size += 1; } checkResize(); } 删除\r对于删除操作，只需要遍历相应的 bucket。如果发现有相同值的节点，删除就行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Override public V remove(K key) { Collection\u0026lt;Node\u0026gt; bucket = buckets[hashIndex(key, buckets.length)]; for (Node node : bucket) { if (node.key.equals(key)) { bucket.remove(node); return node.value; } } return null; } @Override public V remove(K key, V value) { Collection\u0026lt;Node\u0026gt; bucket = buckets[hashIndex(key, buckets.length)]; for (Node node : bucket) { if (node.key.equals(key) \u0026amp;\u0026amp; node.value.equals(value)) { bucket.remove(node); return node.value; } } return null; } ","date":"2024-07-27T00:00:00Z","image":"https://ovideros.github.io/p/cs61b-week8-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/lec20-12_hu22adb50f6d7a902542e86845e16fef58_73917_120x120_fill_box_smart1_3.png","permalink":"https://ovideros.github.io/p/cs61b-week8-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"CS61B week8 学习笔记"},{"content":"lec17 B-Trees(2-3, 2-3-4 Trees)\r二叉搜索树\rBushy vs. Spindly\r对于茂盛的二叉搜索树，高度是 $\\Theta(\\log(n))$ ；而对于细长的二叉搜索树，高度是 $\\Theta(n)$，这时候其实退化成了链表。\n判断\r哪一个提供了更多信息？\n最差情况的 BST 高度为 $\\Theta(n)$ BST 高度为 $O(n)$ 事实上，说最差情况的 BST 高度为 $\\Theta(n)$ 提供了更多信息。因为，大 O 不能说明复杂度会达到那个程度，只能说明小于等于。所以，信息量更少。\n举例来说，你也可以说二叉搜索树的高度为 $O(n^2)$。现实当中，人们通常默认大 O 表示了最坏情况。\n高度、深度与表现\rDepth：某个节点举例根节点的距离。例如，根节点深度为 0，根节点的子节点为 1。 Height：节点深度的最大值。 Average depth：节点深度的平均值。如图。 高度决定了树在最差情况下的时间，平均深度决定了平均情况下的时间。\n随机的树\r如果加入物品的顺序不一样，那么树的高度和平均深度可能不一样，表现也就不一样。\n不过，如果随机加入元素，可以证明平均深度约为 $2\\ln(n)$，树的高度约为 $4.311\\ln(n)$。如果包括删除操作，也可以证明随机的树的性能仍然是 $\\Theta(\\log(n))$。\n然而，如果插入的物品是有序的，那么很可能导致较差的情况。例如，储存有序日期的时候，数据总是有序的，这时候普通二叉搜索树的表现较差。\nB-Trees 2-3 trees 2-3-4 trees\r概念\r为了不增加新的深度，可以考虑将新的节点插入到原先节点。然而，如果插入得过多，显然会降低性能。 可以设置一个限制，如果某个节点多于限制 L，将某个值给父节点。不过，这样有可能失去搜索树的性质。因此，需要增加子节点的数量。\n如果大于 3 个元素，就分割。因此，中间的 16 分割后介于 15 和 17 之间，是 15 17 节点的第二个子节点。\n途中，因为 15 17 19 21 节点的元素个数超过了 3，因此将 17 上升，并分割出 15。\n在这个例子当中，根节点也需要分割。因此，新的根节点变成了 17，同时将 13 和剩下的节点分开。因此，当根节点充满元素的时候，刚好会提升一层高度，树还是充满的。\n分类\r如果让 $L=3$，就像上面的示例，那么也称为 2-3-4 树（aka 2-4 树）。这意味着每个节点可能有 2、3、4 个子节点。\n如果让 $L=2$，那么也称为 2-3 树，因为可能有 2 个或 3 个子节点。\nB 树通常的应用方式有两种：\n很小的 L，例如 2 或 3。是简单的平衡搜索树。 很大的 L，例如上千。在实践中用在数据库或者文件管理系统中。 证明\r可以证明，无论是怎样的顺序，总可以得到 bushy 的树。\n根据 B 树的构造方式，有两个不变量：\n所有叶节点具有相同的高度 一个拥有 k 个物品的非叶节点，肯定有 k+1 个子节点 图中的例子同时违反了这两个不变量。\n性能\r对于 L 为 2 的 B 树，在最差情况下，高度是 $\\log_2(n)$。在最好情况下，高度为 $\\log_3(n)$。所以，高度是 $\\Theta(\\log(n))$。\n对于查找操作，设高度为 H。在最差情况下，需要查找 H+1 个节点，同时每次需要遍历 L 个元素。因此时间为 $O(HL)=O(L \\log(n))=O(\\log(n))$。\n可以证明加入操作和删除操作也是 $O(\\log(n))$。\nlec18 Red Black Trees\r树旋转\r理解\r如果要将 G 向左旋转，那么首先让 P 成为 G 的父节点。此时，P 有三个子节点，不符合。因此，让原先 P 的左子节点 k 成为 G 的右子节点。这样就完成了旋转。 某节点左旋转：设该节点原先的右节点为 x。则旋转后让 x 的左子节点编程该节点。\n旋转还有另一种理解方法：首先让 P 向上与 G 融合。然后将 G 分裂下来，拥有 C 和 k 两个子节点。 作用\r通过旋转，可以改变树的结构，并缩短高度。理论上来说，利用旋转来平衡一个不平衡的树需要 $O(n)$ 的时间。\n红黑树\r可以考虑构造和 2-3 树等价的二叉搜索树。\n对于只有 2 节点的 2-3 树，每个节点只有一个元素，显然就是 BST。如果有 3 节点，那么就有些麻烦。\n可以使用“胶水”链接，就较小的元素放在左侧。\n概念\r2-3 树与左倾红黑树有一一对应关系，同时 LLRB 也就是普通的 BST。其中，红色的链接并没有做什么特殊的事。\nLLRB 的查找与一般的 BST 一样。\n在几乎都是 3 节点的情况下，设2-3 树的高度为 $H$，则对应的 LLRB 树的高度为 $H+H+1=2H+1$。\n性质\r在 2-3 树中，所有叶节点与根节点的距离相同。因此，在对应的 LLRB 中，所有叶节点距离根节点的黑色链接数量相同。同时，因为 2-3 树最多只有 3 节点，因此没有一个节点同时拥有两个红色的链接。 构造\r因为 LLRB 与 2-3 树的对应关系，因此 LLRB 的高度不会超过 2-3 树高度的大约两倍，所以拥有相同的 $\\Theta(\\log(n))$ 性能。\n为了构造 LLRB，可以在插入元素后，通过一些旋转操作，保持 2-3 树与 LLRB 的对应关系。\n1\r因为在 2-3 树中总是在已有节点上添加元素，因此新加入的节点总是红色链接。 2\r在插入后，如果红色连接方向为右下，那么需要旋转，因为 LLRB 中红色连接总是向左下的。 使用两个红色连接，来表示暂时的 4 节点。 3\r在临时的 4 节点中，如果不符合刚刚的临时节点表示方法，就需要旋转，创造某一个节点的左右子连接为红色。 4\r最后，考虑合并。这时候其实并没有涉及到旋转，只需要改变颜色。将所有关于 B 的边的颜色反向。 总结，只需要下面三个操作： 运行时间\r插入时间为 $O(\\log(n))$。同时，旋转和翻转颜色的操作对于每一次插入，也是 $O(\\log(n))$。\n（61 B 没有覆盖 LLRB 的删除，不过可以参考 B 树的删除）\n搜索树总结\rBST 简单，但是可能不平衡 2-3 树（B 树）是平衡的，但较难实现并且相对较慢 LLRB 的插入较容易实现，删除较难 通过维持与 2-3 树的一对一关系实现 Java 的 TreeMap 是红黑树 维持与 2-3-4 树的联系（不是一对一） 允许两侧的辅助链接 实现起来更加复杂，但是明显更快 lec19 hashing\r要使用搜索树，元素必须是可比较的，有什么方法不需要比较呢？同时，有没有可能比 $\\Theta(\\log(n))$ 更快呢？\n可以将数据值（整数）作为索引，创造一个 bool 的数组。真就代表有这个数据，否就代表没有。这样的结构拥有 $\\Theta(1)$ 的 contains(x) 和 add(x) 速度。然而，缺陷也相当明显，浪费了大量的内存，并且无法表示非正整数。\n储存单词\r有一个不聪明的方法，那就是使用第一个字母对应 1 到 26。然而，这样很可能会碰撞，也无法储存数字。\n避免碰撞\r使用每一位字母乘以 27 的对应次方。例如，\u0026ldquo;cat\u0026quot;计算可以得出 $$3\\times 27^{2}+1\\times27^{2}+20\\times 27^{0} = 2234$$其中，a 代表 1，z 代表26。\n对于纯英文单词，只要选择的基数大于等于 26，就不会发生碰撞。\n编码\r从 33 到 126 的 ASCII 吗是可以打印的。 同样，在 ASCII 之外，Unicode 也是支持的。可以用这个方法来 hash 中文。\n整数上溢\r在 Java 中，最大的整数为 2147483647。超过这个数的正数会上溢。这会带来碰撞。\nJava 中 int 的最多元素为 4294967296。如果元素超过这个值，就肯定有碰撞，也就是抽屉原理。\n有两个问题：\n如何处理碰撞？ 如何计算任意物品的哈希码？ 解决碰撞\r可以让 hash 数组表示指针，指向链表。每个链表当中可以有许多物品。\n最差情况时间 Contain Insert Bushy BSTs $\\Theta(\\log(n))$ $\\Theta(\\log(n))$ 数据索引数组 $\\Theta(1)$ $\\Theta(1)$ 索引数组链表 $\\Theta(Q)$ $\\Theta(Q)$ 其中，Q 是最长链表的长度。HashCode 可以利用取余数，得到某一区间内的整数。\n优化\r假设数组的大小是固定的 M，则当 N 不断增大超过 M 后，Q 就与 N 成正比，最终的时间就变成了 $\\Theta(n)$，性能不好。\n因此，考虑让 M 的大小不断增大，这和 [[CS61B project1]] 中 ArrayDeque 类似。如果 N/M 大于某一个数，例如 1.5，那么就让 M 的大小翻倍。\n每一次扩大 M 需要消耗 $\\Theta(n)$ 的时间，但是之后每一次操作只需要消耗 $\\Theta(1)$ 的时间，因此整体的时间复杂度还是 $\\Theta(1)$。\nJava 中的 hash\rJava 中所有对象都必须实现 .hashCode() 方法。默认的方法会返回该对象的内存地址。\nJava 中的 % 对于负数的处理不满足我们的预期，得到的是负数，而不是正数。因此，使用 Math.floorMod(x, mod)。\n警告：\n不要使用 HashSet 或 HashMap 来储存会改变状态的对象 在 override equals 的时候也需要 override hashCode，不然会引发诡异的现象 Java 中 String 实际上使用的指数为 31，而不是 126 这样较大的数。这是因为计算的上溢，导致 126^32=126^33=...=0，所以无法区分多余 32 的字符的字符串。\nlab7\r这个 lab 需要使用二叉搜索树来实现 Map，即 BSTMap。其中，只用实现一些相对简单的方法。而一些复杂的方法，例如 remove、iterator 和 keySet 则是选做。\n泛型处理\r如果希望指定某一个泛型继承自某一个类，自需要使用 bounded type parameter，例如下面的代码：\n1 2 3 4 5 6 7 8 public class NaturalNumber\u0026lt;T extends Integer\u0026gt; { private T n; public NaturalNumber(T n) { this.n = n; } public boolean isEven() { return n.intValue() % 2 == 0; } // ... } 因此，一开始的类就需要写好：\n1 2 public class BSTMap\u0026lt;K extends Comparable\u0026lt;K\u0026gt;, V\u0026gt; implements Map61B\u0026lt;K, V\u0026gt; { } 这是为了保证 key 的类型 K 是可以比较的，因此可以使用 compareTo 方法。\n实现\r为了实现 BSTMap，首先可以定义内部的节点 Node，方便使用递归。显然，每一个节点需要有 key，value，以及左右指针。\n1 2 3 4 5 6 private class Node\u0026lt;K, V\u0026gt; { K key; V value; Node\u0026lt;K, V\u0026gt; left; Node\u0026lt;K, V\u0026gt; right; } 在实例变量中，储存根节点和 size。\n1 2 Node\u0026lt;K, V\u0026gt; root; int size = 0; 这样，clear() 方法清除该树，size() 方法返回大小，都很容易实现。\n1 2 3 4 5 6 7 8 9 10 @Override public void clear() { root = null; size = 0; } @Override public int size() { return size; } 搜索\r为了实现 BST 的搜索功能，首先定义一个帮助函数 searchKey。如果当前节点为空，则返回 null；如果当前节点的值与 key 相同，则返回当前节点；如果要搜索的 key 小于当前值，则在左侧树种查找；否则在右侧树查找。\n1 2 3 4 5 6 7 8 9 10 11 12 13 /** Helper method to recursively search key. */ private Node\u0026lt;K, V\u0026gt; searchKey(Node\u0026lt;K, V\u0026gt; now, K key) { if (now == null) { return null; } if (key.equals(now.key)) { return now; } if (key.compareTo(now.key) \u0026lt; 0) { return searchKey(now.left, key); } return searchKey(now.right, key); } 这样，就可以很方便地实现 containsKey(K key) 方法，只用看是否返回值为 null 即可。\n1 2 3 4 5 6 7 @Override public boolean containsKey(K key) { if (searchKey(root, key) == null) { return false; } return true; } 同样地，查找当前 key 对应的 value 也可以实现：\n1 2 3 4 5 6 7 @Override public V get(K key) { if (searchKey(root, key) == null) { return null; } return searchKey(root, key).value; } 插入\r为了实现插入功能，构造帮助函数。如果当前节点为 null，就直接返回新的包含 key 和 value 的节点。如果插入的 key 小于当前值，则在左侧插入；如果插入的 key 大于当前值，则在右侧插入。如果相等，则说明 key 已经存在，只需要更改 value 即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** Helper method to insert item. */ private Node\u0026lt;K, V\u0026gt; insert(Node\u0026lt;K, V\u0026gt; now, K key, V value) { if (now == null) { keySet.add(key); return new Node\u0026lt;\u0026gt;(key, value, null, null); } if (key.compareTo(now.key) \u0026lt; 0) { now.left = insert(now.left, key, value); } else if (key.compareTo(now.key) \u0026gt; 0) { now.right = insert(now.right, key, value); } else { now.value = value; } return now; } 再次基础上，实现 put 方法：\n1 2 3 4 5 @Override public void put(K key, V value) { root = insert(root, key, value); size += 1; } ","date":"2024-07-24T00:00:00Z","image":"https://ovideros.github.io/p/cs61b-week7-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/lec18-1_hu5803f0d0359789cfc2af66585133fdd8_43197_120x120_fill_box_smart1_3.png","permalink":"https://ovideros.github.io/p/cs61b-week7-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"CS61B week7 学习笔记"},{"content":"lec14 Disjoint Sets\r这个数据结构应该有两个操作：\nconnect(x, y) 连接 x 和 y。 isConnected(x, y) 判断 x 和 y 是否是连接的。同时，连接可能是间接的。 为了实现这个数据结构，重点考虑不同元素是否在同一组当中。一开始，每个元素都是不同的组。如果将两个连接起来，就会把组连接起来。不用考虑具体的连接。\nIdea 1\r使用集合的列表。但是这样查找起来会很慢。例如，如果要判断 5 和 6 是否连接，必须遍历列表，消耗时间为 $\\Theta(n)$。\n实现方法 constructor connect isConnected ListOfSetsDS $\\Theta(n)$ $O(n)$ $O(n)$ Idea 2\r使用一个数组，每个索引对应元素，数组中每个相同的值对应同一个组。这些值只要相同就行，不关心具体数值。现在，因为数组读取特定元素只是常数，所以 isConnected 方法为 $O(1)$。然而，connect 方法还是较慢，需要遍历数组。\n实现方法 constructor connect isConnected ListOfSetsDS $\\Theta(n)$ $O(n)$ $O(n)$ QuickFindDS $\\Theta(n)$ $\\Theta(n)$ $\\Theta(1)$ Idea 3\r数组中，记录每一个节点的父节点。如果值为-1，则代表为父节点。\n在改变连接的时候，只需要修改一个节点就可以。但是，如果树很长，要“爬树”，需要消耗较长时间 $O(n)$；同时，最坏情况下，isConnected 也需要消耗 $O(n)$。\n实现方法 constructor connect isConnected ListOfSetsDS $\\Theta(n)$ $O(n)$ $O(n)$ QuickFindDS $\\Theta(n)$ $\\Theta(n)$ $\\Theta(1)$ QuickUnionDS $\\Theta(n)$ $O(n)$ $O(n)$ Idea 4\r总是将较小的树放在较大的树下面，通过重量来选择。同时，负数的绝对值大小代表成员个数。保证较少元素的树合并到较大元素的树。\n可以证明，树的高度是 $\\Theta(\\log(n))$。\n实现方法 constructor connect isConnected ListOfSetsDS $\\Theta(n)$ $O(n)$ $O(n)$ QuickFindDS $\\Theta(n)$ $\\Theta(n)$ $\\Theta(1)$ QuickUnionDS $\\Theta(n)$ $O(n)$ $O(n)$ WeightedQuickUnionDs $\\Theta(n)$ $O(\\log(n))$ $O(\\log(n))$ Idea 5\r在此基础上，如果找到了一些节点的最终根节点，那么就可以把这些节点的 parent 设置为根节点，这样会更快。\n最初的操作可能好事，但最后会相当接近常数。\nlec15 Asymptotics II\r例子 2\r1 2 3 4 5 6 7 public static void printParty(int n) { for (int i = 1; i \u0026lt;= n; i = i * 2) { for (int j = 0; j \u0026lt; i; j += 1) { System.out.println(\u0026#34;hello\u0026#34;); } } } 一种方法是利用画图，可以夹在两条直线之间。\n另一种方法是 $1+2+4+\\ldots+N=2N-1$。分析的时候需要注意，这与 $1+2+3+\u0026hellip;+Q=\\Theta(Q)$ 不同。\n递归\r对于一些递归的问题，如果每次需要调用两次 n-1 的函数，那么复杂度为 $2^N$。\n对应公式为 $1+2+4+\\ldots+2^{N-1}=2^N-1$。\n二分搜索\r对于排序好的数组，每次查找中间的元素，根据大小再次左右分。对于最不利的大小为 $N$ 情况，需要消耗 $\\log(N)$。因此，时间复杂度为 $O(\\log(n))$。\n排序\r选择排序\r涉及到等差数列的求和，复杂度为 $O(n^2)$。\n合并数组\r对于两个有序数组，将它们合并只需要 $\\Theta(n)$。\n合并排序\r可以把原先的数组分成两个数组，对于两个排序后的数组合并。这样不断二分大小，最终二分的次数是 $\\log(n)$。每一层的合并需要 $\\Theta(n)$。所以，最后的复杂度为 $\\Theta(n\\log(n))$。\nlec16 ADTs, Sets, Maps, BSTs\r抽象数据类型（ADT）\r解释\r类比 Java，ADT 就好像是接口，不关心具体的实现方式，只要满足 API 就行。因此，对于一种 ADT 可以有多种实现。\n不过，不同的实现方式有性能上的差异。例如，对于栈来说，只支持推入和弹出的操作，这时候链表和数组的实现方式带来的复杂度一样（不考虑改变数组大小的话）。\n又例如，对于 GrabBag ADT，支持以下操作：\ninsert (int x)：将 x 插入。 int remove()：随机从袋子中移除一个物品。 int sample()：随机观察袋子中每个物品的值（不删除） int size()：袋子中物品的数量 此时，因为考虑到需要随机读取元素，因此数组会是更好的实现方式，能带来 $\\Theta(1)$ 的性能。 Java 内置 ADT\r大多数有用的接口都在 java.util 中。例如，有 List，Set，Map 等等。同时，Java 也提供了许多有用的实现方式。这一节会学习 TreeSet 和 TreeMap。\n二叉搜索树（BST）\r引入\r对于线性表而言，查找一个元素需要消耗 $\\Theta(n)$ 的时间。如何提升性能呢？可以考虑让指针指向线性表中间的元素，然后翻转左侧的指针。接着，对于左右剩下的部分，也可以做类似的处理。这样递归下去，就可以形成二叉树。\n定义\r树由以下元素组成：\n一些节点的集合。 一些连接节点的边。同时，两个节点之间有且仅有一条路径。 将没有父节点的节点成为根（root），将没有子节点的节点称为叶节点（leaf）。在有根的二叉树中，每个节点拥有 0、1 或 2 个子节点。\n对于二叉搜索树来说，对于每个节点，都有以下性质：\n左侧子节点的值比当前节点的值小 右侧子节点的值比当前节点的值大 同时，这种排序方式需要是明确的。 搜索\r对于二叉搜索树，搜索起来相当简单。如果当前节点的值等于搜索值，就返回。不然，如果搜索值小于当前值，就在左侧子树上搜索；否则在右侧搜索。\n可以发现，对于“茂盛”的二叉搜索树，最差情况下搜索只需要 $\\Theta(\\log(n))$。在实际程序中，这个性能是够用的。\n插入\r搜索当前的插入值。如果找到了当前值，就返回。否则，就需要创建新节点，并且设置新的指针。\n在上面的事例代码中，需要注意，不要写成右侧的代码。右侧代码并没有真正相信递归，没有处理好 base case，只会增加复杂性。实际上，如果没找到节点，就返回新创建节点的指针；如果找到了，就直接返回 T，也就是不改变当前树。这样才是更高效的做法。\n删除\r二叉搜索树的删除分为三种情况：\n要删除的节点没有子节点 要删除的节点有一个子节点 要删除的节点有两个子节点 对于第一种情况，很明显只需要将父节点的指针删去即可。\n对于第二种情况，需要保持二叉搜索树的特性。\n在这个例子中，为了删去 flat 节点，可以发现 flat 的各个子节点都是大于 flat 的父节点——dog，因此可以直接将 dog 指向 flat 的子节点 elf，满足二叉搜索树的特性。\n对于第三种情况，在下图中删除 k 节点。\n这时候，为了方便起见，可以考虑保留 k，只是更换当中的值。那么，这个新的值必须要比左侧所有节点的值大，比右侧所有节点的值小。\n通过观察发现，左子树的最大值 g 和右子树的最小值 m 符合要求，因此可以选取其中之一更换 k 的值。然后，删除 g 或 m。此时，如果要被删除的节点有两个子节点，就不满足上面最小值或最大值的情况，因此该节点只能有 0 个或 1 个子节点，删除它也就变成了前两种情况。\n应用\r二叉搜索树可以实现集合和字典。因为二叉搜索树没有重复元素，因此满足了集合和字典的要求。\n对于集合，只用将元素作为二叉搜索树的值。对于字典，只需要同时储存 key 和 value 即可。\nlab6\r这一个 lab 主要是为了 project 2 做准备，包括如何使用命令行来使用 Java，如何使用路径，以及如何让程序保存状态。\nJava 命令行\r一般来说，先要通过 javac 将源代码转换成二进制类文件，然后使用 java 运行程序。同时，利用命令行运行程序时，命令会储存到 main 的 args 中。\nMake\r通过 makefile，可以方便地编译大型程序。这里也没有细说，只是展示了可以这样，并且提供了 make 来编译程序，使用 make check 来运行本地的测试程序。\nJava 路径\r使用 System 中的方法 getProperty(\u0026quot;user.dir\u0026quot;) 来获取当前路径。\n1 2 3 4 5 6 // file /home/Michelle/example/Example.java class Example { public static void main(String[] args) { System.out.println(System.getProperty(\u0026#34;user.dir\u0026#34;)); } } 也介绍了绝对路径和相对路径的概念。\nJava 文件\r使用如下代码来使用文件。\n1 File f = new File(\u0026#34;dummy.txt\u0026#34;); 创建文件：\n1 f.createNewFile(); 检查文件是否存在：\n1 f.exists() 文件夹在 Java 中也是通过 File 来表示的。例如，创建一个文件夹对象：\n1 File d = new File(\u0026#34;dummy\u0026#34;); 创造文件夹：\n1 d.mkdir(); 序列化 Serializable\r在 java.io.Serializable 有相应的接口，需要继承。\n1 2 3 4 5 import java.io.Serializable; public class Model implements Serializable { ... } 然后，写入类文件：\n1 2 3 4 5 6 7 8 9 10 Model m = ....; File outFile = new File(saveFileName); try { ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(outFile)); out.writeObject(m); out.close(); } catch (IOException excp) { ... } 会将 m 转化为字节，并存储到文件中。之后，可以读入文件：\n1 2 3 4 5 6 7 8 9 10 11 Model m; File inFile = new File(saveFileName); try { ObjectInputStream inp = new ObjectInputStream(new FileInputStream(inFile)); m = (Model) inp.readObject(); inp.close(); } catch (IOException | ClassNotFoundException excp) { ... m = null; } 使用了帮助函数后，写入和阅读更加简单：\n1 2 3 4 5 Model m; File outFile = new File(saveFileName); // Serializing the Model object writeObject(outFile, m); 1 2 3 4 5 Model m; File inFile = new File(saveFileName); // Deserializing the Model object m = readObject(inFile, Model.class); Exercise\r这个练习只需要根据步骤一步步做即可。不过可能是我的终端环境有些问题，怎么改也很难运行 make check。最后只能在 testing/ 文件夹下手动运行 python tester.py --src=our-src .\\our\\test01-basic-story.in 来测试。\n调试\r对于拥有持久性的程序，不能简单地像之前那样调试。不过，可以使用 IDEA 的远程 JVM 调试，设置断点，然后利用终端执行命令，使用 s 步入，就可以使用 IDEA 继续调试。\n","date":"2024-07-21T00:00:00Z","image":"https://ovideros.github.io/p/cs61b-week6-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/tree1_huef42b8e9271cc82ae22061136c29c600_60833_120x120_fill_box_smart1_3.png","permalink":"https://ovideros.github.io/p/cs61b-week6-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"CS61B week6 学习笔记"},{"content":"lec12 Command Line Programming, Git\rGit\r方案 1\r每一次更改都保存所有文件。\n方案 2\r对于不变的文件，保存之前文件的指针。只保存更改后的文件。\n如果要恢复文件，则需要遍历历史，比较麻烦。\n方案 3\r每次记录下每个文件对应的版本，相当于 map 或 dict。如果某个版本和之前的版本，则不用存储新文件。\n方案 4\r使用时间和日期作为版本号码。然而，可能有相同的时间。\n方案 5\r使用 hash。Git 使用的是 git-SHA 1 hash，有 160 bit 长。\n计算 git-SHA 1 hash。例如为 66 ccdc\u0026hellip; 创造文件夹 .git/objects/66 将文件储存在名为 66 ccdc\u0026hellip; 的文件中（使用了压缩） Hash 可能会碰撞，但是概率相当相当小，可以忽略。同时，Hash 也可以更安全。\nCommit\rCommit 的命令也储存在 objects 中。Commit 包含坐着，日期，message，文件和版本的表格，parent ID。对这些使用 git-SHA 1。\nMerge\r在解决冲突过后，新的 commit 拥有两个 parents。这种结构是图。\nlec13 Asymptotics I\r时间复杂度\r将各种操作看成消耗单位时间，计算操作次数。消耗的最多时间记为 $O()$, 消耗的最小时间记为 $\\Omega()$。这都只用看等价无穷大。那么，如果消耗的时间等价与同一个阶数，可以记为 $\\Theta$。\n","date":"2024-07-19T00:00:00Z","permalink":"https://ovideros.github.io/p/cs61b-week5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"CS61B week5 学习笔记"},{"content":"lec 9 Extends, Casting, Higher Order Functions\r继承\r接口继承（Interface Inheritance）：只声明方法。 实现继承（Inplementation Inheritance）：同时说明如何使用。 对于一个类继承另一个类，使用关键词 extends。通过 extends，可以继承所有实例变量和类变量，继承所有方法，还有嵌套的类。然而，却无法继承 private 的成员。\nSuper\r使用 super 来表示父类，使用 super.method 来访问父类的方法。\n每次子类的 constructor 运行时，首先会运行父类的 constructor。但是，对于有输入参数 x 的 constructor，只会调用没有参数的父类方法。因此，此时必须明确地说明 super(x);。\nObject 类\rJava 当中所有的类，都是 Object 的子类。Object 也有一些方法。\nIs vs. Has\r类的继承应该是 is 的关系，而不是 has 的关系。因为子类会继承所有父类的方法，如果说子类是 Stack，父类是 List，那么 Stack 会继承 List 的各种 index, insert 方法，这显然不是我们想要的。\n封装（Encapsulation）\r为了管理复杂性，需要封装。通过接口来访问对象。需要在正确的抽象层级上思考。\n继承破坏了封装\r假设 Dog 类中有以下方法：\n1 2 3 4 5 6 7 8 9 public void bark() { barkMany(1); } public void barkMany(int N) { for (int i = 0; i \u0026lt; N; i += 1) { System.out.println(\u0026#34;bark\u0026#34;); } } 假设子类 VerboseDog 中有如下方法：\n1 2 3 4 5 6 7 @Override public void barkMany(int N) { System.out.println(\u0026#34;As a dog, I say: \u0026#34;); for (int i = 0; i \u0026lt; N; i += 1) { bark(); } } 那么，调用父类的 bark ()后，会再次调用子类的 barkMany ()，从而陷入无限循环。\n编译器类型检查\r只会检查静止类型。如果发现静止类型有可能出错，那么就会编译出错。通常，如果赋值右侧的编译类型是左侧类型的父类，那么会出错。\n使用 Casting 来改变类型，实现类型转换。然而，这也可能会带来风险。\nlec10 Subtype Polymorphism vs. HoFs\r高阶函数\r在 java 中，可以使用 interface 继承，通过在类中定义函数，来做到这一点。\n多态（Polymorphism）\r子类（Subtype）多态\r对于不同的实现方式，使用同样的接口访问。\nMax 函数\r为了实现一个普遍的 max 函数，可以比较各种各样的对象，考虑定义一个 OurComparable 的接口。\n在接口中，声明有 public int compareTo(Object o); 方法。然后，在 Dog 类中，实现该接口，并 Override 该比较方法。\n但是，需要先把 Object 的类型转换为 Dog：\n1 Dog otherDog = (Dog) o; 根据编译器的静态类型检查，无法使用 o.size，只能用 otherDog.size。\n对于比较函数，可以返回 this.size - otherDog.size。负数代表小于，0 代表等于，正数代表大于。\n缺点\r类型转换可能会带来错误。 没有现成的类实现了 OurComparable。不支持其他的正数，浮点，字符串等等。 解决方法\r使用 java 自带的接口 Comparable，拥有 compareTo 方法。同时，接受参数的时候使用泛型，避免转换。通过 implements Comparable\u0026lt;Dog\u0026gt; 实现。\n比较名字\r通过实现 Comparator，并 Override compare 方法来实现。\n1 2 3 4 5 6 public class NameComparator implements Comparable\u0026lt;Dog\u0026gt; { @Override public int compare(Dog o1, Dog o2) { return o1.name.compareTo(o2.name); } } 之后，将 NameComparator 类嵌套在 Dog 类当中，最好加上 static，同时将 public 改成 private。\n然后，创建 public 的获得比较方法的方法：\n1 2 3 public static Comparator\u0026lt;Dog\u0026gt; getNameComparator() { return new NameComparator(); } 使用\n1 Comparator\u0026lt;Dog\u0026gt; nc = Dog.getNameComparator(); 来获取方法。\n总结\r简单来说，Comparable 是将自己与其他对象比较，Comparator 是一个机器比较两个对象。\nlec11 Exceptions, Iterators, Object Methods\r本节需要利用数组来实现 Set 集合。可以方便地实现 void add(T x)，boolean contains(T x) 等方法。\nIteration\r增强 for 循环\rfor(int i : javaset) {...} 实际上，这些代码利用到了迭代器 iterator。\nIterator\r在类当中，需要定义一个 private 的类继承 Iterator：\n1 2 3 4 5 6 7 8 9 10 private class ArraySetIterator implements Iterator\u0026lt;T\u0026gt; { private int wizPos; public ArraySetIterator() { wizPos = 0; } public boolean hasNext() { return wizPos \u0026lt; size; } public T next() { T returnItem = items[wizPos]; wizPos += 1; return returnItem; } } 同时，需要定义一个公开的方法，来返回 Iterator：\n1 2 3 public Iterator\u0026lt;T\u0026gt; iterator() { return new ArraySetIterator(); } 最后，为了让 java 知道这个类实现了迭代器，需要将这个类继承 Iterable：\n1 2 3 4 public class ArraySet\u0026lt;T\u0026gt; implements Iterable\u0026lt;T\u0026gt; { ... public Iterator\u0026lt;T\u0026gt; iterator() { ... } } Object 方法\rToString 方法\r通过 Override toString 方法，可以实现类的打印。也可以使用 StringBuilder 类。\nEquals\r== 只会比较内存中是否有相同的值，对于引用类型，也只会比较是否指向相同的内存。\nIsinstanceof 使用\n1 if (o instanceof Dog uddaDog) {...} 如果 o 不是 Dog 的实例，那么返回 false；否则，将引用内容转换为 Dog，返回 uddaDog。\nlab4 Git and Debugging\r这一个 lab 包括如何解决 git 的分支冲突，以及一个特别微妙的 bug。\nGit\r在 git 当中，通常合并分支可以自动完成。如果遇到分支冲突，需要手动选择要保留的分支，然后再 commit。\n同时，利用 git checkout some_version -- \u0026lt;file\u0026gt; 命令，可以手动选择恢复某一个版本的特定文件。这个功能很有用，可以方便地将某个文件恢复为之前的状态。\nInteger bug\r如果对于 Integer 的实例使用 == 来比较，那么这只对于-128 到127 之间的数才有效。因为这个本质上用到了 caching 之类的技巧。因此，要使用 Object.equal(Integer1, Integer2) 来比较。\nproject1 后半部分\rExtra Credit\r这分为两个任务：第一个是使用随机化测试，将有 bug 的代码与没问题的代码对比，找出错误。第二个是每次记录下执行的操作，然后当做错误信息打印出来。\n第二问其实很简单，只需要在一个 str 上不断扩展每一次的操作即可。然而，我却想复杂了，以为只用打印最近几次的操作，从而还使用了队列。事实上，全部打印出来就可以。\nMaxArrayDeque\r这需要写一个新的类，继承 ArrayDeque，并且加入一些比较的方法。\n因此，首先需要储存比较器，并且初始化：\n1 2 3 4 5 private Comparator\u0026lt;T\u0026gt; originalComparator; public MaxArrayDeque(Comparator\u0026lt;T\u0026gt; c) { originalComparator = c; } 然后，实现 max 方法：\n1 2 3 4 5 6 7 8 9 public T max() { int maxIndex = 0; for (int i = 0; i \u0026lt; size(); i++) { if (originalComparator.compare((T) get(i), (T) get(maxIndex)) \u0026gt; 0) { maxIndex = i; } } return (T) get(maxIndex); } 注意，这当中的类型转换较多，可以说是 Java 多态的特点。\n然后，实现另一个比较方法，可以接受任意的比较器：\n1 2 3 4 5 6 7 8 9 public T max(Comparator\u0026lt;T\u0026gt; c) { int maxIndex = 0; for (int i = 0; i \u0026lt; size(); i++) { if (c.compare((T) get(i), (T) get(maxIndex)) \u0026gt; 0) { maxIndex = i; } } return (T) get(maxIndex); } 本来我以为这就完了，结果在测试的时候，发现原先 ArrayDeque 的 get 方法有问题。仔细一看，才发现原来之前是直接把输入的 index 当成实际数组当中的索引！这明显打破了抽象层级，自然出错。\n于是，进行修改。首先判断 index 是否在范围之内。然后，如果不是环形的话，index 就是 nextIndex(nextFirst) + index。这里之所以使用 nextIndex 方法，就是为了防止 nextFirst 为最后一个索引的情况。\n如果数组是环形的，还需要分类讨论。如果当前索引较小，元素位于数组的右侧，那么索引为 nextFirst + 1 + index；如果当前索引较大，元素位于数组的左侧，那么索引为 index - items.length + nextFirst + 1。\n1 2 3 4 5 6 7 8 9 10 11 12 public T get(int index) { if (index \u0026lt; 0 || index \u0026gt;= size) { return null; } if (!isCircular()) { return items[nextIndex(nextFirst) + index]; } if (nextFirst + 1 + index \u0026lt; items.length) { return items[nextFirst + 1 + index]; } return items[index- items.length+nextFirst+1]; } 注意\rEquals 方法需要对于 Deque 通用，也就是说具有相同元素的 LinkedListDeque 和 ArrayDeque 应该判断为相同。因此，这个比较需要使用一般的接口方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Override public boolean equals(Object o) { if (this == o) { return true; } if (o == null) { return false; } if (!(o instanceof Deque\u0026lt;?\u0026gt;)) { return false; } Deque\u0026lt;?\u0026gt; other = (Deque\u0026lt;?\u0026gt;) o; if (size != other.size()) { return false; } for (int i = 0; i \u0026lt; size; i++) { if (!get(i).equals(other.get(i))) { return false; } } return true; } GuitarHero\r使用 Karplus-Strong 算法来实现。分为三步：\n将 Deque 中每个元素都换成随机噪音，介于 -0.5 到 0.5 的 double 值。 移除第一个元素，并与接下来第二个元素取平均，乘以衰减因素 0.996，加入 Deque 的最后。 播放第二步去除的元素。然后重复第二步。 具体的代码相当容易，只要跟着 TODO 一步步写就行。\n","date":"2024-07-17T00:00:00Z","permalink":"https://ovideros.github.io/p/cs61b-week4-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"CS61B week4 学习笔记"},{"content":"lec6 DLLists, Arrays\rDLList\r在lec5的 SLList中，如果想要实现获取、增加最后一个节点，需要耗费$O(n)$的时间。如何改进这一点呢？\n可以考虑引入一个指针，指向最后一个节点。这样，就可以很方便地获取和增加最后一个节点。然而，如果要删除最后一个节点，这样的方法还需要找到倒数第二个节点，比较耗费时间。\n因此，引入 DLList，也就是双向链表。这样，就可以方便地删除最后一个节点。\n然而，如果按照原先只有一个哨兵，那么，有时候 last 会指向真正的最后节点，有时候会指向第一个哨兵，这样会引入许多条件判断，很不方便。\n有两个解决办法：一、引入首尾两个哨兵。二、循环链表。\n泛型\r可以在类名定义后加上 \u0026lt;pineapple\u0026gt;，尖括号内是任意的名字。后续，可以用这个名字来指代类型。\n数组\r之后介绍了 java 的数组。因为和 C 语言的很像，所以没怎么记笔记。\nguide A level 1\r部分内容引用自TomLazy的CSDN博客。\n紫胡子和他的奴才 Turquoisenail 正在10海里航行。为了更好地航行，他们希望能够创建一张地图。他们设法创建了他们的方形地图，但 Turquoisenail 被绊倒了，把它掉在了碎纸机里。他们设法将碎掉的图像存储到1D 阵列中，但他们需要将其拼成一张 NxN 地图。你很幸运，因为每一块上都写有经度和纬度。编写一个简短的程序来帮助把这些碎片重新组合起来。\n在表格的左上角，0是经度，20是纬度，在这个问题上，你只能使用数组。\n问题一\r对于这个问题的第一部分，制作一个存储经度和纬度的 Piece 类。\n1 2 3 4 5 6 7 8 9 public class Piece { public int longitude; public int latitude; public Piece(int x, int y) { longitude = x; latitude = y; } } 问题二\r这个问题的下一部分是把给定的一维 Piece 数组中的 Piece，(Piece 没有特定的顺序)，放到一个二维数组中，每一行都充满了具有相同纬度的 Piece。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public Piece[][] groupByLat(Piece[] p) { int width = (int) Math.sqrt(p.length); Piece[][] latGroup = new Piece[width][width]; for (int i = 0; i \u0026lt; p.length; i++) { for (int j = 0; j \u0026lt; latGroup.length; j++) { if (latGroup[j][0] == null) { latGroup[j][0] = p[i]; break; } else if (latGroup[j][0].latitude == p[i].latitude) { int counter; for (counter = 0; counter \u0026lt; width; counter++) { if (latGroup[j][counter] == null) { break; } } latGroup[j][counter] = p[i]; break; } } } return latGroup; } 首先，需要计算二维数组的大小。因此使用 Math.sqrt() 函数并转换为 int 类型。然后创建二维数组。\n一开始还没想出来怎么填空，主要是没有搞清楚 i、j 和 counter 的含义。实际上，这里的 i 遍历了 Piece[] p，而 j 则是便利了二维数组的行（第一个索引）。\n每次对于一个碎片 p[i]，都首先看能否放在一个空的第 j 行当中，也就是 latGroup[j][0] == null。如果为真，直接把当前的碎片放入即可。否则，就看当前第 j 行元素的纬度是否和第 i 个碎片的纬度相同。如果不同，就跳过本次循环。如果相同，就利用 counter 遍历这一行，将当前元素放在第一个非空的位置。\n经过以上操作，就通过纬度，将原先的一维数组转换为每一行家具有相同纬度的二维数组。\nlec7 ALists, Resizing, vs. SLists\r相比于链表，数组更方便访问其中的某一个元素。 只需要记下数组的大小，就可以很方便地实现尾部元素的增加和减少。\n不变量\r下一个元素的位置总是 size。 size 总便是 AList 中元素的个数。 最后一个元素的索引总是 size-1。 更改大小\r数组的大小是有限的。如果超出了大小，就需要创建新的数组，满足大小，并且将旧数组都复制到新数组当中。\n如果需要更改大小 $n$ 次，这样做的代价大约是 $O(n^2)$。\n每一次重新分配大小，将大小变为原先的两倍。这样可以明显地提升速度。同时，如果相比于数组的大小，使用的数据量过于小（通常选择 0.25），那么可以将数组大小缩小一半，节省空间。\n泛型数组\r使用 items = (type[]) new Object[n] 来创造泛型的数组。\nlec8 Inheritance, Implements\rmethod overload\r在 java 中，一个类中的方法可以有相同的名字，但是有不同的参数。通过不同的参数，编译器可以判断具体使用哪一个方法。\n接口（Interface）\r有的方法对各种列表都适用，但是非要制定具体的 AList 或 SLList。如果使用 overload，需要复制粘贴代码，修改起来很麻烦。\n解决方法是创造一个 interface，可以代表多种列表。在新的文件中，像这样命名：\n1 public interface List\u0026lt;Item\u0026gt; { ... } 对于接口，可以描述它们做什么，但是不用描述怎么做。例如，主需要写下方法即可：\n1 public Item get(int i); 接着，在 AList 和 SLList类中，修改为这样：\n1 public AList\u0026lt;Item\u0026gt; implements List\u0026lt;Item\u0026gt; { ... } 这样，就可以使用其他方法，对于所有的 List 都有用。\n覆盖（Override）\r对于具体的类，可以选择覆盖方法：\n1 2 @Override public Item get(int i) { ... } 这里的 @Override 虽然不是必须的，但是建议这样写，一方面可以避免拼写错误，另一方面方便其他程序员明白这个方法在 Override。\n在接口中，也可以使用 default 关键字，内置一个方法：\n1 default public void method() { ... } 该方法中可以使用其他接口中的方法。\nStatic vs. Dynamic Type\rStatic type 是唯一确定的，仅仅取决于声明变量时的类型。而 Dynamic Type 可以随着程序而变化，取决于当前指向的对象的类型。\nproject1 前半部分\r这个项目分为两个部分，第一个部分需要实现数据结构，第二个部分则需要利用数据结构实现应用。\n项目介绍\rPackage\r有两个包：deque 用来实现数据结构，gh2 用来实现吉他英雄的合成器。\n包可以包含许多类，实现一个更大的目标。利用文件开头的 package deque;，就表明当前类在 deque 包当中。\n如果其他程序员想用使用某个方法，要么使用全名，也就是 deque.ArrayDeque，要么 import deque.ArrayDeque 后使用简称 ArrayDeque。\n同时，全名是倒着写的。例如，JUnit 库在 junit.org，于是包写成 org.junit。因为不同库当中可能有相同的方法，所以要制定全名或者使用 import。\nDeque\r一般读作\u0026quot;deck\u0026quot;，代表两端队列，既可以从头加入、移除元素，也可以从尾部加入、移除元素。在 The Deque API 中，说明了希望的 API。该项目需要用两种方法来实现 Deque——双向链表和数组。\nLinkedListDeque\r有一些要求：\nadd 和 remove 必须消耗常数的时间。 get 要使用迭代而不是递归。 size 要消耗常数的时间。 使用 for 循环来遍历链表。 不要保留对于不在队列当中物品的引用。 我选择了循环链表加上一个哨兵实现，这样的代码确实比较简洁。在 LinkedListDeque 的内部，我创建了 private Node 类。LinkedListDeque有两个实例变量——Node sentinel 和 int size。\n在只有一个哨兵的时候，哨兵的 prev 和 next 都设置成自身。对于头部和尾部加入元素，需要考虑清楚改变哪些指针即可。\n特别注意，对于 remove 操作，需要考虑 size 为 0 时，如果用户执行 remove，那么 size 还应该为 0。这一点我一开始还没有考虑到，经过测试才发现。\n对于 getRecursive 操作，可以创建一个私有的 helper 函数，输入 Node 和 index，利用递归完成获取第 index 节点的 item。\n完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 public class LinkedListDeque\u0026lt;T\u0026gt; { private Node sentinel; private int size; private class Node { T item; Node prev; Node next; private Node(T item,Node prev,Node next) { this.item = item; this.prev = prev; this.next = next; } } public LinkedListDeque() { this.sentinel = new Node(null, null, null); this.sentinel.next = sentinel; this.sentinel.prev = sentinel; size = 0; } public void addFirst(T item) { Node temp = new Node(item, sentinel, sentinel.next); sentinel.next.prev = temp; sentinel.next = temp; size += 1; } public void addLast(T item) { Node temp = new Node(item, sentinel.prev, sentinel); sentinel.prev.next = temp; sentinel.prev = temp; size += 1; } public boolean isEmpty() { return size == 0; } public int size() { return size; } public void printDeque() { Node p = sentinel; while(p.next != sentinel){ System.out.print(p.item); System.out.print(\u0026#39; \u0026#39;); p = p.next; } System.out.println(); } public T removeFirst() { if (size == 0) { return null; } T value = sentinel.next.item; sentinel.next.next.prev = sentinel; sentinel.next = sentinel.next.next; size -= 1; return value; } public T removeLast() { if (size == 0) { return null; } T value = sentinel.prev.item; sentinel.prev.prev.next = sentinel; sentinel.prev = sentinel.prev.prev; size -= 1; return value; } public T get(int index) { if (index \u0026gt;= size) { return null; } Node p = sentinel.next; for (int i = 0; i \u0026lt; index; i++) { p = p.next; } return p.item; } public T getRecursive(int index) { if (index \u0026gt;= size) { return null; } return recursiveHelper(sentinel.next, index); } /** Private helper for recursively get item. */ private T recursiveHelper(Node p, int index) { if (index == 0) { return p.item; } return recursiveHelper(p.next, index-1); } } Array Deque 简单部分\r要求：\nadd 和 remove 应该消耗常数时间，除非需要 resize。 get 和 size 必须消耗常数时间。 开始的数组大小为 8。 对于长度大于等于 16 的数组，可用率至少为 25%。即 remove 时，如果让可用率低于 25%，则需要 resize。 推荐使用环形的数组。\n初始化\r首先，创造相应数量为 8 的数组。然后，size 赋值为 0，并将 nextFirst 赋值为最后一个索引，nextLast 赋值为 0。\n1 2 3 4 5 6 public ArrayDeque() { items = (T[]) new Object[INIT_SIZE]; size = 0; nextFirst = INIT_SIZE-1; nextLast = 0; } 环形索引\r为了方便地实现环形，定义两个私有的 helper 方法，nextIndex 和 prevIndex。\n1 2 3 4 5 6 7 8 9 10 11 12 13 private int nextIndex(int n) { if (n+1 == items.length) { return 0; } return n+1; } private int prevIndex(int n) { if (n == 0) { return items.length-1; } return n-1; } 增减元素（不考虑 resize）\r对于增加第一个元素，首先需要将索引为 nextFirst 的元素赋值为 item，然后更改 nextFirst 为前一个索引，最后增加 size。\n1 2 3 4 5 public void addFirst(T item) { items[nextFirst] = item; nextFirst = prevIndex(nextFirst); size += 1; } 对于移除第一个元素，需要首先判断 size 是否为 0。如果是，直接返回 null 阶数函数。如果还有元素，则先将元素暂存下来，并清空数组中对元素的 reference，然后更改 nextFirst 和 size，最后返回该元素。\n1 2 3 4 5 6 7 8 9 10 public T removeFirst() { if (size == 0) { return null; } T item = items[nextIndex(nextFirst)]; items[nextIndex(nextFirst)] = null; nextFirst = nextIndex(nextFirst); size -= 1; return item; } 对于 addLast 和 removeLast 函数，方法也是类似的，这里就不再重复了。\n容易实现的方法\rget，isEmpty 和 size 都很好实现，这里就不再赘述。 （其实这里的 get 有 bug，在 week4 的 MaxArrayDeque 中有修改）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public T get(int index) { if (index \u0026gt;= items.length){ return null; } return items[index]; } public boolean isEmpty() { return size == 0; } public int size() { return size; } ArrayDeque Resize\r终于来到了最有意思的地方。相比于双向链表，数组总是有一个固定的大小。如果需要更改大小，就需要手动赋值数组。\n同时，我们是通过循环数组来实现的。这就意味着，必须要判断当前的数组是否是循环的。例如，[X, 2, 3, 4, X, X] 就是不循环的，因为所有的元素都在中间部分；[2, 3, X, X, 5, 6]就是循环的，因为该数组的第一个元素是 5，然后是 6，接着因为循环，下一个元素变为 2，然后是 3。因此，需要编写函数来判断当前数组是否循环。\nisCircular\r跟函数需要返回是否循环。利用之前的 Index 操作，可以方便地找到当前数组的首元素索引和尾元素索引。然后，如果首元素的索引大于尾元素的索引，就代表存在循环；否则，不存在。\n1 2 3 4 5 6 /** If circular, return true.*/ private boolean isCircular() { int first = nextIndex(nextFirst); int last = prevIndex(nextLast); return first \u0026gt; last; } CheckExpand\r每次扩张数组时，都有可能使得当前元素个数超出数组范围。因此，每次 add 操作前都需要判断。为此编写判断的函数：\n1 2 3 4 5 6 7 8 /** Check whether after add new item, * the AList needs to expand. If so, call expandSize.*/ private void checkExpand() { if (size != items.length) { return; } resize(size * 2); } 这里选择每次扩大一倍，因为一开始的大小也是 8，这样成倍扩大后数字比较整齐。\nResize\r对于数据的更改大小，首先需要创造一个新的数组，然后将当前数组中的元素复制进新的数组。这需要分类讨论：\n如果当前数组循环，则需要从首元素到数组末尾赋值到新数组，然后从数组头部到尾元素复制到新数组。 如果当前数组不循环，则只需要复制中间部分到新数组。 复制完成后，将 items 指向新的数组，然后更新 nextFirst 为新的大小-1，nextLast 为原先大小。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** Expand array to newSize.*/ private void resize(int newSize) { T[] newArray = (T[]) new Object[newSize]; int first = nextIndex(nextFirst); // if the items are circular if (isCircular()){ System.arraycopy(items,first,newArray, 0,items.length-first); System.arraycopy(items,0,newArray, items.length-first,nextLast); } else { System.arraycopy(items,first,newArray,0,size); } items = newArray; nextFirst = newSize-1; nextLast = size; } checkEmptySpace\r如果一开始加入了很多元素，之后又减少了很多元素，那么数组不应该耗费太多空间。所以，每次删除元素的时候，都需要检查是否有多余的空间。为此编写 checkEmptySpace 函数。\n根据要求，如果当前数组长度大于 16，并且空闲率（元素个数除以数组长度）小于 0.25，那么就需要缩小数组。此时，因为空闲率小于 0.25，所以可以将数组缩小为原先长度的一半。\n1 2 3 4 5 6 7 8 /** Check whether empty space exists.*/ private void checkEmptySpace() { if (items.length \u0026gt;= MAX_EMPTY_SIZE \u0026amp;\u0026amp; size \u0026lt; 0.25*items.length) { resize(items.length / 2); } return; } 经过这些函数，数组双向队列可以基本实现。\n完整的项目代码见github上的my-cs61b。\n","date":"2024-07-15T00:00:00Z","image":"https://ovideros.github.io/p/cs61b-week3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/circular_hu0cb3e8a5ae6461545981ed543138b0ea_88986_120x120_fill_box_smart1_3.png","permalink":"https://ovideros.github.io/p/cs61b-week3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"CS61B week3 学习笔记"},{"content":"前言\r为什么没有week1的内容呢？🧐\n答案是我偷懒了，没有写。😴\n以下记录一些自己上cs61b的感悟，以及编程的思路。完整的项目代码见github上的my-cs61b。\nlab2\r这个 lab 2 主要是教你如何使用 IDEA 的 Debugger 来 debug。\n对于这种现代化的 IDE，debug 确实比较容易，可以方便地显示不同变量，提供步入步出等操作，起到隔离信息的作用。\n理想的 debug 模式：首先根据一行代码和当前变量，预期这一行代码的功能。如果一致，就说明这一行没出错；如果发现矛盾，说明这一行有问题，或者这一行调用的函数有问题。这时候，可以进一步步入函数。重复上面的步骤，直到发现问题所在。\n理想的 debug 应该实现抽象的功能，不能直接就步入每一个函数，不然只会增加工作量。应该先假设所有函数都能正常工作，直到找到不满足预期的情况。这样，才能高效地找到代码出错的部分。\n同时，课程还强调了测试驱动开发（Test-driven development, TDD）。在实际编写各种函数之前，首先写一些测试用例，同时可以考虑一些边缘的情况。然后，测试一下，自然全部都无法通过。这时候，先聚焦于比较简单的测试，想办法让该测试通过。然后，聚焦于剩下失败的测试，直到最后通过所有测试。\n相比于直接写代码，先写测试可以让你明确输入输出用例。在实际例子的帮助下，可以对代码有更深的理解。一个个通过的测试，也能像玩游戏一样，增加开发的动力。\nlec5 SLLists, Nested Classes, Sentinel Nodes\r相比于直接的 IntList，SLList 提供了更好的 api，拥有 addFirst() 方法和 getFirst() 方法，方便调用。\nPrivate\r对于用户来说，不用考虑递归的细节。\n通过将一些类的成员设置成 private，那么类之外无法访问这些成员。这可以隐藏细节。事实上，private 也不是绝对不能访问，可以用库做到这一点。它更像是一种提醒。\nNested class\r可以在类当中定义其他的类。\n嵌套的类可以实现更多的功能。\n保持代码简单\r不要增加过多特殊情况。最好寻找普遍的方法，覆盖各种情况。\n可以对链表引入假头，又称为哨兵 (sentinel)。\nproject0 2048\r这个项目需要你去实现 2048 游戏的核心功能。自然地，作为第 0 个项目，许多繁杂的部分，包括 GUI、随机生成方块、各种类的抽象，都已经写好了。只需要在 Model.java 中继续写游戏的核心逻辑即可。\n这个项目的前三个函数都很容易，最后一个tilt函数有点意思。\nemptySpaceExists\r原型： public static boolean emptySpaceExists(Board b)\n该函数接受一个 Board 输入，然后判断是否有空的格子。这需要使用 Board 的方法 tile(int col, int row) 从而得到具体的格子。需要注意，如果某个地方没有 Tile，那么该方法返回的是 null，而不是 0。我想之所以要这样写，是因为这样可以更明确地表示某个地方为空。如果是 0，可能在后续编写代码的时候有歧义。\n同时，也需要用到 Board 的 size() 方法，获得大小。代码相当简单，只需要用一个二层循环遍历每一个格子，如果某一个格子为空，返回 true 即可。否则返回 false。\n1 2 3 4 5 6 7 8 9 10 11 public static boolean emptySpaceExists(Board b) { int n = b.size(); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { if (b.tile(i,j) == null) { return true; } } } return false; } maxTileExists\r原型：public static boolean maxTileExists(Board b)\n这个函数用来检验是否有达到最大值的格子，也就是 2048。这里强调了不要直接将数字硬编码写在程序里，避免 magic number，而是要使用常量，如 MAX_PIECE 来表示2048。\n相当简单，同上，二层循环遍历格子即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static boolean maxTileExists(Board b) { int n = b.size(); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { if (b.tile(i,j) == null) { continue; } if (b.tile(i,j).value() == MAX_PIECE) { return true; } } } return false; } atLeastOneMoveExists\r原型：public static boolean atLeastOneMoveExists(Board b)\n这个函数用来判断当前是否有存在可以移动的空间。如果 Board 上还有空的格子，自然可以继续移动。如果全满，则判断是否有相邻的相同大小的格子存在。如果有，则说明还可以移动。\n要解决这个问题，可以分成两个部分——水平相邻和竖直相邻，分别检验，二者对称。可以使用二层循环。\n在检验过程中，如果发现相邻中任何一个格子为 null，则跳过当前循环。然后，使用 b.tile(col, row).value() 来获取值并且比较。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public static boolean atLeastOneMoveExists(Board b) { if (emptySpaceExists(b)) { return true; } int n = b.size(); // check whether horizontal adjacent tiles exists for (int i = 0; i \u0026lt; n-1; i++) { for (int j = 0; j \u0026lt; n; j++) { if (b.tile(i,j) == null || b.tile(i+1,j) == null) { continue; } if (b.tile(i,j).value() == b.tile(i+1,j).value()) { return true; } } } // check whether vertical adjacent tiles exists for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n-1; j++) { if (b.tile(i,j) == null || b.tile(i,j+1) == null) { continue; } if (b.tile(i,j).value() == b.tile(i,j+1).value()) { return true; } } } return false; } tilt\r原型：public boolean tilt(Side side)\n这个函数接受 Side 输入，表明往哪个方向移动。同时，方法需要修改 Board 至移动后的状态，同时增加 score 变量的值，并将 changed 变量设置为 true。\n所有的移动操作都要使用 Board.move(col, row, tile)。\n移动规则\r以下的X代表该格子为空。\n两个相同值的格子，会合成一个有两倍值的格子。 合成过后的格子不会再次参与合成。例如[X, 2, 2, 4]向左移动，则会变为[4, 4, X, X]，而不是[8, X, X, X]。 如果有大于等于 3 个相邻格子，则会先合并移动方向上的两个格子。例如，[X, 2, 2, 2]向左移动会得到[4, 2, X, X]而不是[2, 4, X, X]。 简化的手段\r首先，如果有四个移动的方向，那么最后可能要把已有的结果复制粘贴四次，并进行修改。这样很明显相当麻烦，并且很容易出错，增加了维护难度。\n因此，Board 已经内置了 setViewingPerspective(side) 方法。只要首先设置视角的方向，就可以把各个方向的操作，都转换成向上移动的操作，然后使用同样的代码求解，最后再把视角变换回来。\n同时，合并的具体过程已经经过抽象了。只需要使用 broad.move(col,row,tile) 方法。如果该移动后与原先格子发生合并，则该函数返回 true，否则返回false。\n方法\r在向上移动的时候，很明显每一列都是相互独立的，因此可以考虑封装每一列，传入 Board 和当前列的索引，进而使代码简化。\n在每一列中，因为都是向上移动，因此总可以从上往下考虑每一个格子。\n需要记录的状态\r在 public boolean tiltColumnNorth(int col) 方法中，传入 col，执行一列的操作，并且返回 boolen 代表有没有改变。\n对于每一列，从上到下，将 row 从 n-1 遍历到 0。\n为了记录好每次的状态，需要以下变量：\nrow：当前行数 lastValue：上一格的值。一开始设置为-1。 val：现在一格的值。只有在当前格非空时才有用。 lastTileRow：上一格的位置。一开始设置为 n。 isLastMerged：上一格是否合并过。一开始设置为 false。 可能的动作：\n不移动当前格。 移动当前格，但是不合并。 移动当前格，同时合并。 一开始，我没要搞清楚这几种动作，并且都写在一个函数里面，导致很难维护。后来，根据这些状态，写了一个函数calculateState，根据返回值来确定状态。然后，在 tiltColumnNorth 方法当中使用 switch 语句。\nCalculateState\r不移动的情况。这时候，row 等于 lastTileRow-1，并且上一格的值和这一格的值不相等。（此处这一格的值和上一个相等，就一定能移动，因为是从上往下遍历，不会出现上面一个格合并后还和下面的格紧挨着） 移动但是不合并的情况。这时候，要么 val 不等于 lastValue，要么 isLastMerged 值为真，也就是上面一个格合并过。 移动并且合并。是上面两种情况的剩下情况。 TiltColumnNorth\r获取状态后，就容易执行相应的操作了。\n不移动时，lastTileRow 减少 1，isLastMerged 为假，lastValue 赋值为 val。 移动但不合并时，将当前格移动到(col, lastTileRow-1)处，changed 为真，isLastMerged 为假，lastTileRow 减少 1，lastValue 赋值为 val。 移动并且合并时，将当前格移动到 (col, lastTileRow)处，changed 为真，isLastMerged 为真，lastTileRow 减少 1，lastValue 赋值为两倍的 val。 最后返回 changed。\n完整代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 /** Tilt the board toward SIDE. Return true iff this changes the board. * * 1. If two Tile objects are adjacent in the direction of motion and have * the same value, they are merged into one Tile of twice the original * value and that new value is added to the score instance variable * 2. A tile that is the result of a merge will not merge again on that * tilt. So each move, every tile will only ever be part of at most one * merge (perhaps zero). * 3. When three adjacent tiles in the direction of motion have the same * value, then the leading two tiles in the direction of motion merge, * and the trailing tile does not. * */ public boolean tilt(Side side) { boolean changed; changed = false; // TODO: Modify this.board (and perhaps this.score) to account // for the tilt to the Side SIDE. If the board changed, set the // changed local variable to true. board.setViewingPerspective(side); int n = board.size(); for (int col = 0; col \u0026lt; n; col++) { if(tiltColumnNorth(col)) { changed = true; } } board.setViewingPerspective(Side.NORTH); checkGameOver(); if (changed) { setChanged(); } return changed; } /** Tilt a certain column towards NORTH, * if changed, return true; * else, return false */ public boolean tiltColumnNorth(int col) { int n = board.size(); int lastTileRow = n; boolean changed = false; boolean isLastMerged = false; int lastValue = -1; for (int row = n-1; row \u0026gt;= 0; row--) { Tile t = board.tile(col, row); if (t == null) { continue; } int val = t.value(); switch (calculateState(lastTileRow, isLastMerged, lastValue,val,row)) { // don\u0026#39;t move case 0: lastTileRow--; isLastMerged = false; lastValue = val; break; // move, don\u0026#39;t merge case 1: board.move(col, lastTileRow-1, t); changed = true; isLastMerged = false; lastTileRow--; lastValue = val; break; //move and merge case 2: board.move(col, lastTileRow, t); changed = true; isLastMerged = true; score += 2*val; lastValue = 2*val; break; } } return changed; } /** Calculate state. * if return 0, don\u0026#39;t move * if return 1, move but don\u0026#39;t merge * if return 2, move and merge */ public int calculateState(int lastTileRow, boolean isLastMerged, int lastValue, int val, int row) { if (row == lastTileRow-1 \u0026amp;\u0026amp; lastValue != val) { return 0; } else if (val != lastValue || isLastMerged) { return 1; } else { return 2; } } ","date":"2024-07-13T00:00:00Z","permalink":"https://ovideros.github.io/p/cs61b-week2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"CS61B week2 学习笔记"},{"content":"▶️ 前言\r时间过得飞快，如今我已是老登了。去年的今日，我还在暑假期间打 P5r。鉴于自己的成绩还挺不错的，于是想要整理一下一年以来用过的学习资料，以供各位大一学生参考。虽说主要是信科，但是大一的课大差不差。就算是电信、精工、特立等学生，也可以来看看，大概80%的内容是可以参考的。\n本文大概分为三个部分——思想篇，方法篇还有资料篇。在思想篇里，我会简单地介绍一些视频或网站，帮助各位完成从高中到大学思维的转变。在方法篇里，我会介绍一些我认为的合理方法，帮助各位高效学习。在资料篇里，我会对各个科目列举出我当时使用过的学习资料，供各位参考。\n⚠️更新⚠️：24级的信科在课程上有些变化。将大学计算机改成了人工智能与计算科学A，将学术用途英语改成了基础英语，3学分变成了4学分。 这些课都是第一次排课，也只能小登们自行探索了。\n🌞 关于暑假\r大学从来不是四年。有人说，大学只有三年，因为保研的流程从大三的寒假开始，直到大四的 9 月 28 号，满打满算也只有三年的时间；考研要在大四的 12 月初试，也没有四年。也有人说，大学有五年，因为如果想要在竞赛或科研中取得较好成果，假期是几乎必须要牺牲的；如果把牺牲的寒暑假加起来，那么大学就有五年。\n为什么我要这么说呢？答案是：高考后的暑假是最方便玩的暑假。如果以后想要走保研的路，那么高考暑假大概率是一生中最长的假期了。所以，好好玩吧。喜欢社交的可以多交些朋友，喜欢宅的可以多看看 ACGN，喜欢干什么就干什么吧。因为我暑假也是玩过来的，所以个人给不上任何建议。\n💛 心态篇\r鉴于独特的教育环境，大学和高中的转变，远远比小升初、初升高的转变要大。这个过程可能是艰难的，但我希望各位通过充分了解，可以让这个过程更加轻松。\n以下，我会推荐五个有关大学认知的视频或文章，帮助大家思考。我在这只起到推荐作用，如果你有兴趣，也可以自行探索相关内容，进行更加深入的了解。我希望能帮助同学们拓宽视野，找到在大学中前进的方向。\n1️⃣\r普通出身，如何最大限度“利用”大学？【学生请一定看完！】\n该视频先提出了优势与弱势学生的划分，进而提出了两种类型的学生——“目标掌控者”与“直觉依赖着”。这两者的形成正是源于学生曾经所处的环境。\n在以上的分析以后，作者提出了解决方案：“学生必须主动投入，积极投身学校的各类教育实践, 提升学习成果，主动与老师和同学互动，才更有可能取得成功。”作者因此鼓励我们减少自己所谓的“标签”，努力保持积极投入的状态；要克服道德策略，挑战习以为常的观念。在最后，作者也表达了自己的希望与祝福。\n2️⃣\r在第一个推荐后，各位也许会想：“如何积极投入大学呢？”那么，下面的的视频，就是专门解决这个问题的。\n一个视频讲透大学的一切！2023年所有高校均适用\n可以看到，这个视频有 2 个多小时，相当长。自然地，没必要一次性看完，可以慢慢看。\n该视频从大学的重要话题谈起，之后介绍了大学的信息渠道，阐释了如何规划大学道路，最后还讲了一下各个年级的主要工作。可以说，大学中80%以上的问题，都可以在其中找到答案。\n3️⃣\r“大学物理”背后的教学问题与社会问题\n视频梗概\r开头，作者提问：为什么许多大学生对于大学物理不理解甚至抵触？为什么许多本科基础课程被大量人吐槽？有没有正确的路，让理工科学生学好物理及其他基础学科？\n一：物理学科的真正面貌\n物理的普遍性。数学与物理的区别。物理将数学当做重要工具，但物理也很看重直观想象。\n二：“大学物理”可能出现的学习与教学问题\n第一：高中和大学脱节\n第二：基础课程与专业需求脱节\n第三：高数与大物的比较\n接着，作者给出建议：\n教学问题不能上升到对学科本身的批判 打好数学基础 走出高中物理的舒适圈，体现在要注意公式的适用范围 远离题海战术，注重整理 三. 一些社会问题＆结束语\n个人感悟\r所幸，北理在大物的安排上相对科学，从大一下才开始学。这意味着，在学习大物时，同学们已经有了微积分的基础。同时，工科数学分析里面也有一些与物理相结合的知识点与题目，这起到了一定的衔接作用。\n然而，我也不能一味说北理的好话。如果把视野扩大，我依然能看到现有本科教育存在着的一些问题。例如，在高度信息化的时代，在纸上画工程制图真的有用吗？又比如，在信息技术日新月异的今天，十几年前的大学计算机实验软件，在表达形式上是否过于落后？诸如此类的问题的确存在着。\n4️⃣\r上海交通大学生存手册\n《上海交通大学生存手册》，写于 08 年，后经过一些修改。这本册子的内容之广，难以简单概括。在此，我仅仅截取一些“名言警句”，希望能激励各位去阅读它：\n“国内绝大部分大学的本科教学，不是濒临崩溃，而是早已崩溃。”\n“我衷心希望这本书能够带给读者一些新鲜的思考，让同学们能看到人生道路上不同的风景。至少在读过本书之后，各位读者应该能够有勇气、有智慧，去发现并挑战那些比上课更为重要的追求。”\n“如果一个人把政策评分作为自己的至高追求，那么他就是这个政策的牺牲品。”\n“学习最需要的，不是悲壮的毅力，而是对无限未知的渴求。”\n“某个环境的条件如何如何之好并不是你去到某个环境中的理由，你能从这个环境中获得什么样的成就，才是你前往某个环境的原因。”\n5️⃣\rCS自学指南 “这是一本计算机的自学指南，也是对自己大学三年自学生涯的一个纪念。”该书由北大的一名信科学生所写，包含了许多部分：必学工具，环境配置，经典书籍推荐，以及最重要的——国外高质量 CS 课程汇总。\n在前言中，作者详细讲述了自己的大学体验，揭示了自己写作此书的理由，还分析了自学的好处与坏处。这当中的资源相当丰富，涵盖面也相当广。在 CS 方面，如果各位有什么想学的知识，在其中基本都可以找到相应的推荐。\n用作者自己的话来说：“当然，作为一个还未毕业的本科生，我深感自己没有能力也没有权利去宣扬一种学习方式，我只是希望这份资料能让那些同样有自学之心和毅力朋友可以少走些弯路，收获更丰富、更多样、更满足的学习体验。”\n🔧 方法篇\r经过高中三年的折磨，如果各位想要继续在学习上取得进步，按照惯性，大概也会沿着高中学习的方向来走。然而，鉴于极度应试的环境，高中也带来了不少自我感动乃至于摧残式的学习方案。当然，下面也只是表示我个人的看法，学习方法也因人而异，仅供各位选择性参考。\n🏫 关于一些学习行为\r简单来说，学习的目的在于获得更多的知识，拓宽自己的视野，而不是获得更多所谓的学习时长。在我看来，效率是比时间要重要的多的。$1.5 \\times 4= 1 \\times 6$，高效的四小时的学习要好于低效的 6 小时学习。\n同时，有一些学习行为也没有太多作用。例如，抄笔记、手抄错题等。在信息化日渐普及的今天，在可以使用各类电子产品的大学，抄笔记不如直接找到书本的电子版，或者把感兴趣的内容拍下来；手抄错题更是没意义，如果用平板等设备来刷题，可以很方便地利用软件来整理。\n📚 什么是高效的学习\r那么，什么样的学习是高效的呢？简单来说，如果某一种方法让你在学的过程中越感到费脑子，那么这个方法就越高效。因为简单的行为——抄笔记、被动听课，都几乎不怎么需要思考；然而更有效的学习方法——整理一门课的大纲、深入研读课本、选择性听课、按类别主动整理错题等，都需要更高的参与度。只有充分调动大脑，让你在学的时候感到有些费脑子，这个方法才是有效的。\n📓 我的日常学习过程\r在日常上课过程中，我一般都是认真听课的。然而，遇到思政课、水课、或讲得实在烂的专业课，我确实不怎么听。对于理工科课程，最重要的是听懂一些思想，例如工数的极限思维、积分思维，线代的一些抽象思维，大物的形象理解，电分的叠加、等效、变换三大方法等等。这些思维对于理解各类理工科，都是通用的。\n课后，认真完成作业。同时，一定要关注慕课、乐学等在线平台的截止时间，否则会扣平时分。\n对于一些自己认为没有特别理解的概念，我会选择寻找一些学习资料，来帮助自己理解。我主要通过课本，其他教材还有 b 站视频来寻找。同时，也有些人会看 MOOC，延河课堂等等。\n可以说，我在平时阶段没有那么应试，还是注重真正的理解。因为，很多时候考试是千变万化的，无法保证今年的难度和往年相同。举两个例子：22-23 年的工数下是有往年题以来最难的一届，题量大，计算量恐怖；在老师将许多人捞到 60 分后，平均分也只有 65 分。又比如 23-24 年的电分，也就是我们大一下信科类的电分，在我刷过 20 年以来的所有试卷后，我敢说今年是最难的，没有之一。如果有兴趣，各位在大一下也可以挑战一下这些试卷。\n所以，平时阶段还是要真正理解概念，不能纯粹应试。否则，期末考试可能会超出你的意料之外。\n🤺 考前突击\r大学的一大特色就在于考前突击。区别于高中三年认真学 6 门科目，在大学中，你一个学期就要学相当于高中三年的知识量。此时，不管平时学得怎么样，考前突击都是必需的。对于比较重要的课，我考前突击的时间线比较长，可以有两周到三周。不过，如果某个课重要程度一般，并且时间比较紧，一周的时间大概也够了。\n往年试卷是最好的参考。虽然我上面说不能只看往年卷，不过如果往年卷都不看，那我不知道有什么更好的资料。\n我一般会把有记录的考试卷全部都刷一遍。有的科目从 04 年开始，有的科目从 08 年开始。然而，我并不是每一个试卷都从头刷到尾，而是借用了机器学习的方法——划分训练集和测试集。具体来说，如果有过往 16 年的往年题，我可能把前 12 年的题目当成训练集，最近 4 年的题目当成测试集。\n对于训练集的题目，我会根据题型来刷。例如，当我复习完工科数学分析上的极限这一章，我就会一个个看训练集当中的题目。如果找到了极限的题目，就做一做；对于其他还没有复习到的章节，则不管。就这样，每复习完一章，就做完训练集中的所有相关题目，并在最后作总结。这样，这一章差不多就通关了。\n在考前最后 2-3 天，可以开始做测试集的题目。这时候，尽量按照考试的要求来严格模拟。做试卷的时候找集中的时间做，模拟考场的氛围。如果你学得比较好，你往往会发现，自己做的时间远低于考试的 2 个小时。然而，这些科目往往又会有不少的低级错误。例如，我发现我做线代往年题大概只要 1 个小时，工数上往年题只要一个小时十几分钟。对于这种科目，考试的时候一定要放慢解题步骤，不要太快，否则很容易出现低级错误。相反，有的科目题量较大，例如我发现如果认真画完工图，就要用 1 个小时 40 多分钟；因此，对于此类科目，考场上要保持较快的速度，不能太慢。\n考试前，不要熬夜，尽量保持最充足的睡眠。这样考试的时候才能有最好的状态。\n📃 资料篇上\r关于军训\r军训会影响学分，分为两个部分：军事技能和军事理论。军事技能 2 学分，如果获得了优秀标兵什么的，可以加分。军事理论 2 学分，在军训最后闭卷考试，很简单，考前会发题库，背下来就行。\n工科数学分析Ⅰ\r大一上最重要的一门课，有 6 学分。内容是单变量微积分，包括极限、微分、积分。很显然，这是对高中导数的延续，通过研究导数的逆运算——积分，可以解决实际理工科当中许多问题。\n在此，推荐 3blue1brown 的视频。该视频从导数讲起，深入极限的本质，还涉及到了泰勒展开。可以说，这是对微分学相当好的入门视频。\n【官方双语/合集】微积分的本质 - 系列合集\nUP 主汉语配音【微积分的本质】合集\n在科普方面，推荐一下《微积分的力量》这本书。这个书讲了微积分的各个方面，公式不多，高中生就能看。自然地，科普书看不看关系也不大。\n同时，推荐一下《普林斯顿微积分读本》。该书讲得很细致，深入浅出，不需要太多数学基础就可以看。学好这本书，可以为单变量微积分基础打下坚实的基础。\n在 b 站上有些教学视频，例如宋浩、梨米特等等。因为我数学基础较好，所以看了些考研难度的考研竞赛凯哥。\n最后复习阶段，要重点看每一章最后一节综合例题，也要认真做每一章最后的综合习题。可以配合《工科数学分析习题全解》。这当中许多来源于往年压轴题，如果吃透这些题，你就具有了考 100 分的资格。当然，这些题难度较高，如果时间紧，可以不看。\n线性代数 B\r信科学习的是线代 B，与线代 A 相比，简单不少。不过，线性代数对于之后理工科还是相当重要的，因此最好多学一学。\n在几何直观理解方面，强烈推荐 3b1b 的视频——线性代数的本质。该视频以线性变换为中心，利用几何直观，展现出线代的美丽画卷。同时，也可以看看漫士沉思录的无痛线代系列，也通过几何直观，讲解了线代的应用。\n【官方双语/合集】线性代数的本质 - 系列合集\nUP 主汉语配音-【线性代数的本质】合集 线性代数很难学？因为没有深刻理解这个概念【无痛线代】\n我们学校有一位线代的名师——吴惠彬老师。非常有幸上了吴老师的课，老师的上课节奏把握得很好，深入浅出，平时分给满，是最理想的大学老师。也可以在延河课堂上看老师的录播。\n同时，MIT 的课也很不错。\n麻省理工学院 - MIT - 线性代数\n最后突击期间，刷往年题就够了。线代B 的题型很固定，多刷刷就能上 90。\n工程制图 C\r信科的工图C 是最简单的工图。然而，这门课对信科后续学习几乎没什么作用，除非搞机器人的机械设计啥的。如果老师讲得不太行，可以看看清华的课\n【清华大学】机械制图 58 集全\n自然，这个课当中有些内容是涉及不到的，选择性观看即可。\n工图有三次大作业。我们班这一届第一次大作业要在 A 3 纸上画图，第二次用 CAD 电脑画二维图，第三次用 SolidWorks 建三维模型。可能有其他班都是在纸上画的。如果对电脑不太熟悉，可以参考一些 B 站教程。\n「速成」全网最简单的 AutoCAD 入门教程没有之一 「速成」全网最简单的 SW 入门教程没有之一（上）\n大学计算机\r这是我大一上包括各类思政课，考得最低的一门课。这门课本身就挺抽象的，本意是过一遍计算机知识，然而实际上用各种陈旧的信息，十几年前的实验软件，实在很没意思。往年题也不多。\n顺带一提，我还被大计的慕课背刺过。这个慕课考试在期末考试之后，导致我根本没看慕课，结果慕课就 45 分。折算成 20% 到总分里面，太痛了。所以直到出成绩前，一定要常常检查慕课。\n只能推荐一下计算机科学速成课，这个视频做的挺好的。\n【计算机科学速成课】[40 集全/精校] - Crash Course Computer Science\n思想道德与法治\r作为一门思政课，重点还是在于背诵。同时，还有一个红色文物大赛的项目，有兴趣可以组队做一下，算是比较容易水的竞赛。\n期末考试只会考几道大题，背诵的时候只用背重点内容，考试的时候临场发挥，拥有正能量即可。\n知识产权法基础\r水。考试的时候开卷，可以带课本，直接抄就行。\n学术用途英语一级\r英语平时分占 40%，口语考试占 20%，期末占 40%。英语课成绩主要要看老师。如果老师不错，那么你可以在愉悦的情况下拿下不错的成绩。如果不幸遇上了“冥师”，那么确实很折磨。\n考试题型和四六级比较像。大一上就可以把四级考了，顺便刷一些四级题目，增加一些英语应试能力。\n形势与政策\r水中水，0.25 学分。注意论文查重率，不要挂科就行。\n大学生心理素质发展\r水中水中水，0 学分，事有点多，但不挂就行。\n国家安全概论\r1 学分，但是最后是等级制，也就是优秀对应 95 分，良好对应 85 分（记不清了，可能是）。没有考试，主要是平时作业和结课论文。认真让 gpt 写一下就行。\n📑 资料篇下\r大一下相比于大一上，有了很大的变化。23届大一上期末周只有3门课程，其他课在之前就已经考完了。而大一下只有电分提前考，剩下六门课都在考试周。\n如图，橙色的点代表大一上的科目，蓝色的点代表大一下的科目。很明显，大一上的科目的平均分高于大一下科目，同时大一下科目还有更多高学分的课。这就导致大一下课程又多又难。下面，我将简单介绍一下各个科目。\n工科数学分析 Ⅱ\r工数下有 6 学分，仍然是大一下最重要的课。相比于工数上的单变量微积分和常微分方程，工数下拓展到多变量微积分，理解难度上了一个台阶。\n可以在寒假期间看一看 3b1b 在可汗学院的视频，从几何直观讲解了多元微积分。\n（熟肉合集）多元微积分，微分部，3 Blue 1 Brown Grant Sanderson 讲授——可汗学院\n与工数上一样，b 站上宋浩、梨米特、考研竞赛凯哥等也可以看。\n最后突击期间，最好做一下每一章的综合例题和综合习题，不过难度确实很大。最好配合《工科数学分析习题全解》。往年题还是要刷的。\n大学物理 A Ⅰ\r简而言之，量大。包含力学、热学、波动、光学，有许多公式。如果想要学好，需要耗费一些精力。\n强烈推荐郭爷的物理讲解。作为北理光电学院的教师，郭爷讲的大学物理相当好。在高中时期，我学物理竞赛的时候，就受到了郭爷不小的帮助。到如今，也是在他的帮助下，我大物上才取得了高分。\n2019-2020-4-大一春季《大学物理-上》完整版本 75 课时\n大物的慕课较多，需要每周注意完成。最后期末复习时，可以刷课本上每章后的习题，刷往年题。\n电路分析基础\r电分作为电路的专业入门课，有一些难度。一开始的纯电阻电路还比较好理解，但是进入动态电路之后，便上了难度。学好电分，需要对工数上的常微分方程熟悉，同时理解叠加、分解和变换三大方法。书上前言写得其实不错，可以看快。\n石群老师讲得很细，不过太长了，我也只看了一点点。 电路石群老师主讲【80 集全带目录】\n我主要还是看课本。相比于 ppt，课本的原理部分讲解更多，解释更加详细，可以帮助理解。应试方面，这个考研视频也可以看看。\n邱关源《电路》第六版课后习题详解 1-8 章\n考前突击时，期末卷还是要写的。慕课上的题质量不错，可以复习。\nC 语言程序设计\r这是我大一下理科中考得最烂的一门。C 语言的考试分为三个场次，每个场次有两套试卷。我在下午考，有 C 卷和 D 卷。我看都没看，就选择了 C 卷，结果有道题目比较恶心，没写出来。然而，据说 D 卷相当简单，我有个同学一个小时就写完了。所以，如果各位可以选择试卷，一定要先把两张试卷的大题都看完，然后选择更容易的一张试卷。\n对于 OI 选手，我不敢提什么建议。如果没学过编程，可以看看 CS50 的前几讲，生动并且详细地介绍了 C 语言。\n【中文精翻】【CS 50】哈佛大学计算机科学导论课 (2023) - CS 50 Lecture 0 - Scratch\n日常的乐学编程题最好尽早做。考前可以做一下课本每章后的选择题，这些题在 csdn 上有答案。\n物理实验 B Ⅰ\r简而言之，折磨王。给它 1 点学分，它可以每周占用 4-5 个小时。再给它一次选课的机会，它能让广大学生破防。\n选课方面，可以问问学长，有一些选课秘籍可以帮助你抢到课。也可以问一些给分较好的老师。实验的预习报告可以在思政课上抄。\n学术用途英语二级\r和英语一级一样，要看老师。最后考试的听力很恶心，建议多刷一些六级听力。虽说如果你英语实力不是很好，我不建议大一下就考六级，因为大一下的期末周前很忙。\n中国近现代史纲要\r这个课有微课大赛，有兴趣的话可以水一水。该课还有一个实践活动。\n最后一节课要认真听。同时，考前可以看一下速成视频。\n【古埃及掌管史纲的神】史纲速成｜第一章 进入近代后中华民族的磨难与抗争｜Strik0r\n习概\r有的老师会要求课前放一些表演的视频。最后一节课有 ppt 划重点，考试几乎都是考重点，背好重点即可。\n形势与政策\r水中水，注意查重率就行。\n⏹️ 尾声\r以上都是关于分数的。然而，大学远远不只这些。就学业方面，还有竞赛和科研。竞赛方面，如果有 OI 经历，自然可以想办法入 acm 队；如果对自动化、机器人感兴趣，可以考虑机器人队、航模队、智能车队等等。大一下也有许多竞赛的机会，可以尝试大创、挑战杯、数学竞赛、数学建模竞赛等等。科研方面，大一确实有些早，可以之后再考虑。\n学业之外，大学还有更多。在百团大战，可以多看看不同种类的社团和学生组织，参加一些自己感兴趣的。多了解一些新的事物，尝试一些新的方法，毕竟，大学是试错成本相当低的场所。\n最后，我也要对给予过我帮助的老师们，朋辈导师们，耐心的学长学姐们，表示深深的感谢。\n","date":"2024-07-11T15:45:07+08:00","image":"https://ovideros.github.io/p/%E4%BF%A1%E7%A7%91%E5%A4%A7%E4%B8%80%E9%80%9A%E5%85%B3%E6%8C%87%E5%8D%97/grades_hu1140f049c82ac1bdd0a53595f9c2e19c_74005_120x120_fill_q75_box_smart1.jpg","permalink":"https://ovideros.github.io/p/%E4%BF%A1%E7%A7%91%E5%A4%A7%E4%B8%80%E9%80%9A%E5%85%B3%E6%8C%87%E5%8D%97/","title":"信科大一通关指南"},{"content":"前言\r🚧🚧🚧\n本笔记主要参考了3b1b的线性代数的本质，以及漫士沉思录的线性代数系列。本文尚未完成，还在施工中\u0026hellip;🫠\n🚧🚧🚧\n基本概念\r向量\r向量是线性代数中最基本的概念。一个向量在不同人的眼中，可以有许多种理解。对于物理学家，向量就是既有大小又有方向的量，不在乎起点；对于计算机科学家，向量就是一个数列，储存着一定顺序的数字。对于数学家，向量可以更加抽象，只要满足“线性”性质，就可以是向量。\n向量的线性性质\r对于向量来说，拥有以下两种运算，便具有线性：\n数乘。向量整体乘以 $k$，就是每个分量都乘以 $k$。乘了数之后，该向量仍然具有意义。 相加。两个向量相加，就是每个分量分别相加。新的向量仍具有意义。 向量最基本的几何含义，表示从原点开始，指向坐标系中某一点的有向线段。该向量可以数乘 $k$，代表该向量在经过原点的一条直线上运动。两个向量相加，符合平行四边形法则，且可以先沿着 $x$ 轴移动一段距离，再沿着 $y$ 轴移动一段距离，符合定义。\n从这个角度上来说，物体的位移、速度，显然可以加倍，也可以相加，所以是向量。电路当中的多个支路电流组成向量，可以数乘——代表状态翻倍；也可以相加，代表电路在不同激励下的响应。类似地，化学方程组中元素的个数，也可以看做向量。\n线性组合\r“线性代数”中，“线性”显然是一个重要的因素。线性组合的概念，也与向量的线性性质关系紧密。已知有两个向量 $\\vec{x}$ 和 $\\vec{y}$，此时， $$ a\\vec{x}+b\\vec{y} $$ 就是两个向量的线性组合，其中 $a$ 与 $b$ 为任意实数。\n张成的空间\r拥有了 $n$ 个向量之后，便可以考虑这 $n$ 个向量之间的线性组合。随意变化每个向量前面的系数，就可以得到一大堆向量。为了方便想象，默认这些向量的起点都是原点，可以用向量的终点来表示一个向量。此时，线性组合产生的所有向量，可以看成一个空间，也称为由 $n$ 个向量张成的线性空间。\n例如，对于零向量，张成的空间就是原点。对于一个非零向量，张成的空间是过原点的一条直线。对于两个不共线的向量，张成的空间就是一个过原点的平面。\n线性相关与基底\r线性相关\r理解了张成的空间后，便可以考虑一些独特的情况。例如，明明有两个二维向量，但是它们共线，于是最终张成的空间只是一条直线。这时候，可以认为有一个向量是多余的，因为一条直线最少只需要一个向量就可以张成。该多余的向量也可以由另一个向量线性组合得出，因为都在同一个直线上。\n接着，考虑三维中的情况。如果有三个共平面的向量，那么只能张成一个过原点的平面。此时，任意一个向量显然可以通过另外两个向量线性表示，因为该向量处在另外两个向量张成的空间上。\n更一般地，只要存在某一个向量可以被其他向量线性组合得出，那么这些向量就是线性相关的。\n线性无关\r显然，线性无关是线性相关的对立面。如果每一个向量都不能被其他向量线性组合得出，那么，这些向量就是线性无关的。更严谨地说，就是不存在一组不全为 0的 $k_1,k_2,\\ldots,k_n$，使得 $$ k_1\\vec{x_1}+k_2\\vec{x_2}+\\ldots+k_n\\vec{x_n}=0 $$ 这里，之所以要强调不全为 0，就是因为如果系数全为 0，显然等式恒成立。因此要排除这种情况。\n基底\r对于一个线性空间，总可以用一些向量张成。此时，如果这些向量线性相关，那么可以去掉一个向量；如果还线性相关，可以继续删去向量，直到这些向量是线性无关的。此时，我们便找到了张成这个空间所需的最少向量，这些向量可以成为该空间的基底，这些向量的个数就是空间的维数。\n线性变换与矩阵\r线性变换\r线性变换，又可以叫线性映射，可以看成一个函数。它的输入是一个向量，输出也是一个向量。那么，区别于其他函数，线性变换有什么特点呢？答案也是线性： $$ f(k\\vec{x})=kf(\\vec{x}) $$ $$ f(\\vec{x}+\\vec{y})=f(\\vec{x})+f(\\vec{y}) $$ 先来考虑一些几何直观。经过线性变换之后，某个向量如果是其他向量的线性组合，那么，变换后的该向量也是变换后其他向量的线性组合，系数不变。以二维平面为例，可以理解为变换后坐标网格仍然平行分布且等距，同时原点不动。\n线性变换在理工科中普遍存在，拥有广泛的应用空间。例如，对于鸡兔同笼问题，将数头数脚的过程看成变换，输入为鸡和兔数量组成的向量，输出为头和脚数量组成的向量。如果输入的动物数量翻倍，显然头和脚的数量也翻倍。对于两个笼子，可以分别根据鸡兔数量算出头和脚，再相加；也可以看成一个笼子，直接数出鸡兔的数量，得到头和脚的数量。因此，该变换满足线性性质。所以，是一个线性变换。\n同样，对于化学方程式配平，将输入看成各个化学物质前的系数，输出为元素左边总量减去右边总量。根据元素守恒，输出应该是零向量。显然，将输入翻倍，也就是把化学方程式两边乘以一个系数，仍然成立。将两个化学方程式相加，也就是对应系数相加后，输出可以是分别作用的相加，也可以看成一个式子的结果。因此，该变换满足线性性质。\n矩阵的由来\r既然我们涉及到了线性变换，那么，如何用定量的方式来表示一个线性变换呢？答案是利用线性变换的性质：某个向量如果是其他向量的线性组合，那么，变换后的该向量也是变换后其他向量的线性组合，系数不变。\n特别地，变换前的向量使用基向量线性组合表示，那么变换后的向量也可以用变换后的基向量表示。因此，只要记录变换后的基向量在哪里，就可以完全描述线性变换。\n在二维空间中，假设变换后的 $\\vec{i}$ 变为 $$ \\begin{bmatrix}a \\\\ c \\end{bmatrix} $$ 变换后的 $\\vec{j}$ 变为变为 $$ \\begin{bmatrix} b\\\\ d \\end{bmatrix} $$那么，将这两个向量按列拼起来，就可以得到 2 乘 2 的矩阵 $$ \\begin{bmatrix} a\u0026amp;\tb\\\\ c\u0026amp;\td \\end{bmatrix} $$ 这就是矩阵的由来。\n矩阵的含义\r正如前面所说，矩阵表示线性变换，因此有 $$ \\begin{bmatrix} a\u0026amp;\tb\\\\ c\u0026amp;\td\\\\ \\end{bmatrix} \\begin{bmatrix} x\\\\ y\\\\ \\end{bmatrix} =x \\begin{bmatrix} a\\\\ c\\\\ \\end{bmatrix} +y\\begin{bmatrix} b\\\\ d\\\\ \\end{bmatrix} $$ 这代表原先空间中某一向量 (x, y)，变换过后的坐标，可以通过 x 数乘变换后的 $\\vec{i}$ 加上 y 乘以变换后的 $\\vec{j}$ 得到。因此，可以得到矩阵乘以向量的计算公式。不难看出，这也可以推广到 3 维空间或者更高维的情况。\n矩阵乘以矩阵\r矩阵乘以矩阵代表什么呢？我们可以这样想：首先考虑变换前的某一向量。经过第一次变换，向量移动到了某个新的位置。再经过第二次变换，向量到达了第二个位置。此时，因为变换是线性的，所以两次变换后，网格仍然平行且等距，原点不变，这表示可以用一个线性变换等效两次线性变换。这也就是矩阵的乘法由来： $$ M_2M_1=M $$ 注意，因为矩阵和函数一样，放在输入量的左侧，因此该式子表示先进行 $M_1$ 变换，再进行 $M_2$ 变换。\n矩阵乘以矩阵如何计算呢？还是从线性变换的角度来考虑。原先的 $\\vec{i}$ 经过第一次变换，变成了 $M_1$ 的第一列。这个向量再经过第二次变换，通过矩阵和向量的乘法，就可以得到 $\\vec{i}$ 经过两次变换的最终位置，也就是 $M$ 的第一列。同理，可以计算出 $M$ 的第二列。这也很容易推广到高维矩阵的情况。\n直观理解的优点\r考虑这样一个问题： $$ M_2M_1?M_1M_2 $$ 这个等式成立吗？从数值的角度，不方便理解。但是从几何的角度，这很直观。考虑逆时针旋转 90 °的变换，以及将 $\\vec{j}$ 移动到 (1,1)的剪切变换。如果先转 90°，再剪切，那么此时 $\\vec{i}$ 会移动到 (1,1)。如果先剪切，再转 90°，那么 $\\vec{i}$ 是 (0,1)。显然，这两种情况下， $\\vec{i}$ 变换后的坐标不一样，所以不相等。\n再比如： $$ (AB)C=A(BC) $$ 这个式子要怎么证明呢？数值上看上去比较复杂，但是如何从几何的角度，这相当显然。因为先 $C$，再经历 $AB$ 等效的线性变换，与先经历 $BC$ 的等效变换，再经历 $A$ 的线性变换，显然是相等的。\n列空间和秩\r列空间\r一个矩阵可以看成是许多个列拼起来得到的。这时候，我们考虑每一个列中的向量，它们张成的空间是什么呢？事实上，这些列向量也就是变换后的基底，因此，这些列向量的线性组合，就是经过矩阵的线性变换之后，所得到的新的空间。\n秩\r对于不同的矩阵，它的列空间不一样。对于这些不同的列空间，最重要的区别就是维度。例如，对于这个矩阵 $$\\begin{bmatrix} 1\u0026amp;\t4\\\\ 2\u0026amp;\t8\\\\ \\end{bmatrix} $$ 显然，它的第一列和第二列线性相关，因此，它的列空间是一条直线，维度为 1。此时，为了衡量列空间的维度，我们称这个矩阵的秩为 1。\n事实上，在严格的线性代数教材中，会证明一个矩阵的各行组成的向量组的秩和各列向量组成的向量组的秩是一样的。\n满秩\r如果一个矩阵的秩就等于该矩阵的维度，就表示该经历该线性变换后，维度没有发生变化。这时候，可以称该矩阵满秩。\n线性方程组\r线性方程组的表示\r如果说为什么线性代数能够在这么多理工科中拥有广泛的应用，最基本的，就是因为线性代数可以方便地求解多元一次方程组，并且采用一种简单、一致的方法求解。\n$$ \\begin{cases} ax+by=e\\\\ cx+dy=f \\end{cases}\\Leftrightarrow \\begin{bmatrix} a\u0026amp;\tb\\\\ c\u0026amp;\td\\\\ \\end{bmatrix} \\begin{bmatrix} x\\\\ y\\\\ \\end{bmatrix} = \\begin{bmatrix} e\\\\ f\\\\ \\end{bmatrix} $$ 如公式，二元一次方程组可以表示为一个二维向量乘以 2 x 2 矩阵，得到了新的二维向量。从线性变换的角度，已知某个向量变换后的位置，需要求出变换之前所在的位置。\n满秩线性方程组的解法\r如果这个变换之后的维度与变换之前的维度相同（也就满秩），并且矩阵是方阵，那么问题相对简单。此时，只需要找到该变换的逆变换，将逆变换作用到变换后的向量，就可以得到变换前向量的位置。这就好像是倒放一样，从后面的向量反向推出之前的向量。使用公式来表示，也就是 $$ x=A^{-1}b $$\n逆矩阵的计算原理\r经过一次变换，再经过一次逆变换，相当于没有变换，也就是基底的位置没有移动。这可以便是为单位矩阵 $I$，其主对角元都为 1，其他都为 0。则对于满足上述条件的矩阵，有 $$ A^{-1}A=I $$ 通过这个式子，如果想要计算 $A$ 的逆矩阵，有一个方法：通过高斯消元法，想办法将 $A$ 变为 $I$，同时，在 $A$ 矩阵右侧并上单位矩阵 $I$，每一次高斯消元法时，同时对一整行处理。这样，当你把 $A$ 变为 $I$ 时，可以看成给 $A$ 做了一次线性变换，这个变换就是 $A$ 的逆。同时，这个变换也记录在了原先 $A$ 右侧的单位矩阵上，通过变换，它变成了 $A^{-1}$。\n零空间\r上述讨论的，都是不改变空间维数的变换。如果空间维数改变，就不能通过上述方法求解了。这时候应该怎么办呢？\n首先考虑较为简单的情况：一个线性变换将二维平面压成了一维直线。这种维度上的缺失意味着什么呢？这意味着原先肯定有多个点，在变换后被压成了同一个点。否则，不可能让维度发生变化。\n这同时意味着该矩阵的秩为 1，不满秩。因此，肯定存在某一个列向量线性组合为 0。 $$ k_1\\vec{x_1}+k_2\\vec{x_2}=0 $$ 同时，该线性组合的系数也可以任意变化，因为等式右侧为 0，两边可以任意乘以系数。那么，考虑如果画出 $$ \\begin{bmatrix} k_1\\\\ k_2 \\end{bmatrix}​ $$ 那么，会组成一条直线。这条直线上每一个向量，经过线性变换，都会到达原点。因此，称这条直线为矩阵的零空间。\n更一般地，如果有一个三阶矩阵秩为 2，就代表将三维空间压缩成二维平面。此时，零空间也是过原点的一条直线。如果有一个三阶矩阵秩为 1，就代表将三维空间压缩成一条一维直线，这时候，零空间是经过原点的一个平面。\n可以发现，矩阵的秩加上零空间的维度，总等于矩阵本身的列数。或者说，矩阵的列空间的秩加上零空间的秩，等于列数。这是线性代数基本定理。\n齐次线性方程组的解法\r如果线性方程组的常数项为 0，就是齐次的情况。这时候，求线性方程组的解，就是寻找矩阵的零空间。这可以通过高斯消元法化简，进而表示出零空间的基底，从而写出零空间的表达式。\n非齐次线性方程组的解法\r对于非齐次线性方程组，首先需要经历齐次线性方程组同样的求解步骤，先求解出零空间。然后，通过代入值，可以找到一组特解。\n此时，非齐次特解加上齐次通解，因为线性的性质，所以总满足原等式。所以，非齐次线性方程组的解也就是非齐次特解加上齐次通解。\n行列式\r行列式的由来\r很多国内教材第一章就讲行列式，然而，我却选择在此处才讲到行列式。因为只有通过线性变换的视角，行列式才更有意义。\n对于不同的线性变换，有的线性变换是扩张性的，将网格向外拉伸；有的线性变换是收缩性的，将网格向内挤压。应该如何描述这两者情况的不同呢？基于线性性质，可以考虑某一块面积在变换前后的大小之比。如果变换后面积变大，那么是扩张性的；如果面积变小，那么是收缩性的。\n对于不同的网格区域，因为是线性变换，所以可以知道，这些区域面积变化的比例是一样的。就算对于一个不规则区域，也可以利用微积分的思想，将其分为许多不同的小块，每个小块的面积变化比例相同。\n行列式的性质\r行列式有几个基本的性质： 1. $$ \\det(\\vec{u},\\vec{v})=\\det(\\vec{u}+k\\vec{v},\\vec{v}) $$ 在几何上，这代表平行四边形的一边可以在其直线上移动，不改变面积的大小。又称为平移不变形。 2. $$ \\det(\\vec{u_1}+k\\vec{u_2},\\vec{v})=\\det(\\vec{u},\\vec{v})+k\\det(\\vec{u_2},\\vec{v}) $$ 这表示的是行列式的线性性质。可以将其中一个向量分成多个向量的和，再分别计算这些向量和另一个向量的行列式，最后相加。 3. $$ \\begin{vmatrix}1\u0026amp;0\\\\0\u0026amp;1\\end{vmatrix}=1​ $$ 这也是二维面积的最初定义。对于更高维的情况，也就是单位矩阵的行列式为 1。\n行列式的计算\r通过以上三条性质，可以证明 $$ \\begin{bmatrix}a\u0026amp;b\\\\c\u0026amp;d\\end{bmatrix}​=ad-bc $$ 这也就是二维行列式的计算公式。对于三维行列式，可以通过行列式的性质，化简为多个二维行列式。这又被成为行列式的展开。\n🚧🚧🚧\n施工中，未完待续\u0026hellip;😶‍🌫️\n🚧🚧🚧\n","date":"2024-07-09T17:02:35+08:00","image":"https://ovideros.github.io/p/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/cover111_hu87de9121abb1737434a06c4b544edc20_178388_120x120_fill_box_smart1_3.png","permalink":"https://ovideros.github.io/p/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","title":"线性代数基本概念"}]